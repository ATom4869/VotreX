{
  "address": "0x7B0cbc3C732E0597c2BADb4e6563F2C27352c097",
  "abi": [],
  "transactionHash": "0x206f757d03291eebb3770945fabd2868f8293f49f812b331638945b410437bd3",
  "receipt": {
    "to": null,
    "from": "0xe3c5Fd667F54BCdF1910cFe61fC39c3F490cbba7",
    "contractAddress": "0x7B0cbc3C732E0597c2BADb4e6563F2C27352c097",
    "transactionIndex": 2,
    "gasUsed": "66022",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x8843d86819fb85266e4fba3d20bd7d9d1ff1745c5af4c931fa5a8b4d9e372de7",
    "transactionHash": "0x206f757d03291eebb3770945fabd2868f8293f49f812b331638945b410437bd3",
    "logs": [],
    "blockNumber": 17378163,
    "cumulativeGasUsed": "172042",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "e8214b3e937a27f6da50d2363d6a2998",
  "metadata": "{\"compiler\":{\"version\":\"0.8.27+commit.40a35a09\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/UtilityLibrary.sol\":\"UtilityLibrary\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100},\"remappings\":[],\"viaIR\":true},\"sources\":{\"contracts/UtilityLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.7.0;\\n\\nlibrary UtilityLibrary {\\n\\tfunction calculateAge(\\n\\t\\tbytes32 encryptedDate,\\n\\t\\tint256 timeOffset\\n\\t) internal view returns (int256) {\\n\\t\\tuint256 SECONDS_PER_YEAR = 31556952;\\n\\t\\t// Step 1: convert encryptedDate (bytes32) \\u2192 int256\\n\\t\\tint256 rawEpoch = int256(uint256(encryptedDate)); // unwrap from bytes32\\n\\n\\t\\t// Step 2: remove offset to get real epoch time\\n\\t\\tint256 birthEpoch = rawEpoch - timeOffset;\\n\\n\\t\\t// Step 3: now use current time (block.timestamp) which is uint256 \\u2192 cast to int256\\n\\t\\tint256 nowEpoch = int256(block.timestamp);\\n\\n\\t\\t// Step 4: handle negative (invalid future date)\\n\\t\\tif (birthEpoch > nowEpoch) return -1;\\n\\n\\t\\tint256 age = (nowEpoch - birthEpoch) / int256(SECONDS_PER_YEAR);\\n\\t\\treturn age;\\n\\t}\\n\\n\\tfunction isOver60Years(\\n\\t\\tbytes32 birthDate,\\n\\t\\tint256 timeOffset\\n\\t) internal view returns (bool) {\\n\\t\\tint256 age = calculateAge(birthDate, timeOffset);\\n\\t\\treturn age >= 60;\\n\\t}\\n\\n\\tfunction extractOrgId(\\n\\t\\tstring memory _userElectionID\\n\\t) internal pure returns (string memory) {\\n\\t\\tstring[] memory parts = UtilityLibrary.splitString(\\n\\t\\t\\t_userElectionID,\\n\\t\\t\\t\\\"-\\\"\\n\\t\\t);\\n\\t\\trequire(parts.length > 0, \\\"Invalid custom election ID format\\\");\\n\\n\\t\\treturn parts[0];\\n\\t}\\n\\n\\tfunction decodeBytes10(bytes10 data) internal pure returns (string memory) {\\n\\t\\tstring memory decodedString = new string(10);\\n\\n\\t\\tassembly {\\n\\t\\t\\tmstore(add(decodedString, 32), data)\\n\\t\\t}\\n\\n\\t\\treturn decodedString;\\n\\t}\\n\\n\\tfunction capitalizeFirstLetter(\\n\\t\\tstring memory str\\n\\t) internal pure returns (string memory) {\\n\\t\\tbytes memory bStr = bytes(str);\\n\\t\\tif (bStr.length == 0) return \\\"\\\"; // Return empty string if no input\\n\\n\\t\\t// \\u2705 Convert first letter to uppercase\\n\\t\\tif (bStr[0] >= 0x61 && bStr[0] <= 0x7A) {\\n\\t\\t\\t// Check if lowercase a-z\\n\\t\\t\\tbStr[0] = bytes1(uint8(bStr[0]) - 32);\\n\\t\\t}\\n\\n\\t\\t// \\u2705 Convert the rest to lowercase\\n\\t\\tfor (uint256 i = 1; i < bStr.length; i++) {\\n\\t\\t\\tif (bStr[i] >= 0x41 && bStr[i] <= 0x5A) {\\n\\t\\t\\t\\t// Check if uppercase A-Z\\n\\t\\t\\t\\tbStr[i] = bytes1(uint8(bStr[i]) + 32); // Convert to lowercase\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn string(bStr);\\n\\t}\\n\\n\\tfunction arrayContains(\\n\\t\\tstring[] storage array,\\n\\t\\tstring memory element\\n\\t) internal view returns (bool) {\\n\\t\\tfor (uint256 i = 0; i < array.length; ++i) {\\n\\t\\t\\tif (\\n\\t\\t\\t\\tkeccak256(abi.encodePacked(array[i])) ==\\n\\t\\t\\t\\tkeccak256(abi.encodePacked(element))\\n\\t\\t\\t) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n\\tfunction onlyAlphanumericCharacters(\\n\\t\\tstring memory _input\\n\\t) internal pure returns (bool) {\\n\\t\\tbytes memory b = bytes(_input);\\n\\t\\tfor (uint i = 0; i < b.length; ++i) {\\n\\t\\t\\tif (\\n\\t\\t\\t\\t!((uint8(b[i]) >= 48 && uint8(b[i]) <= 57) || // 0-9\\n\\t\\t\\t\\t\\t(uint8(b[i]) >= 65 && uint8(b[i]) <= 90) || // A-Z\\n\\t\\t\\t\\t\\t(uint8(b[i]) >= 97 && uint8(b[i]) <= 122)) // a-z\\n\\t\\t\\t) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction allowWhiteSpace(\\n\\t\\tstring memory _input\\n\\t) internal pure returns (bool) {\\n\\t\\tbytes memory b = bytes(_input);\\n\\t\\tfor (uint i = 0; i < b.length; ++i) {\\n\\t\\t\\tif (\\n\\t\\t\\t\\t!((uint8(b[i]) >= 48 && uint8(b[i]) <= 57) || // 0-9\\n\\t\\t\\t\\t\\t(uint8(b[i]) >= 65 && uint8(b[i]) <= 90) || // A-Z\\n\\t\\t\\t\\t\\t(uint8(b[i]) >= 97 && uint8(b[i]) <= 122)) || // a-z\\n\\t\\t\\t\\tuint8(b[i]) == 32 // Space\\n\\t\\t\\t) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction appendToStringArray(\\n\\t\\tstring[] memory array,\\n\\t\\tstring memory newValue\\n\\t) internal pure returns (string[] memory) {\\n\\t\\tstring[] memory newArray = new string[](array.length + 1);\\n\\n\\t\\tfor (uint32 i = 0; i < array.length; ++i) {\\n\\t\\t\\tnewArray[i] = array[i];\\n\\t\\t}\\n\\n\\t\\tnewArray[array.length] = newValue;\\n\\n\\t\\treturn newArray;\\n\\t}\\n\\n\\tfunction uintToString(uint48 value) internal pure returns (string memory) {\\n\\t\\tif (value == 0) {\\n\\t\\t\\treturn \\\"0\\\";\\n\\t\\t}\\n\\n\\t\\tuint48 temp = value;\\n\\t\\tuint48 length;\\n\\t\\twhile (temp != 0) {\\n\\t\\t\\tlength++;\\n\\t\\t\\ttemp /= 10;\\n\\t\\t}\\n\\n\\t\\tbytes memory buffer = new bytes(length);\\n\\t\\tuint48 i = length - 1;\\n\\t\\twhile (value != 0) {\\n\\t\\t\\tbuffer[i] = bytes1(uint8(48 + (value % 10)));\\n\\t\\t\\tvalue /= 10;\\n\\t\\t\\ti--;\\n\\t\\t}\\n\\n\\t\\treturn string(buffer);\\n\\t}\\n\\n\\tfunction uint2str(\\n\\t\\tuint _i\\n\\t) internal pure returns (string memory _uintAsString) {\\n\\t\\tif (_i == 0) {\\n\\t\\t\\treturn \\\"0\\\";\\n\\t\\t}\\n\\t\\tuint j = _i;\\n\\t\\tuint len;\\n\\t\\twhile (j != 0) {\\n\\t\\t\\t++len;\\n\\t\\t\\tj /= 10;\\n\\t\\t}\\n\\t\\tbytes memory bstr = new bytes(len);\\n\\t\\tuint k = len;\\n\\t\\twhile (_i != 0) {\\n\\t\\t\\tk = k - 1;\\n\\t\\t\\tuint8 temp = (48 + uint8(_i - (_i / 10) * 10));\\n\\t\\t\\tbytes1 b1 = bytes1(temp);\\n\\t\\t\\tbstr[k] = b1;\\n\\t\\t\\t_i /= 10;\\n\\t\\t}\\n\\t\\treturn string(bstr);\\n\\t}\\n\\n\\tfunction compareStrings(\\n\\t\\tstring memory a,\\n\\t\\tstring memory b\\n\\t) internal pure returns (bool) {\\n\\t\\treturn (keccak256(abi.encodePacked(a)) ==\\n\\t\\t\\tkeccak256(abi.encodePacked(b)));\\n\\t}\\n\\n\\tfunction splitString(\\n\\t\\tstring memory str,\\n\\t\\tstring memory delimiter\\n\\t) internal pure returns (string[] memory) {\\n\\t\\tbytes memory strBytes = bytes(str);\\n\\t\\tbytes memory delimiterBytes = bytes(delimiter);\\n\\n\\t\\tuint delimiterCount = 1;\\n\\t\\tfor (uint i = 0; i < strBytes.length; ++i) {\\n\\t\\t\\tif (strBytes[i] == delimiterBytes[0]) {\\n\\t\\t\\t\\t++delimiterCount;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tstring[] memory parts = new string[](delimiterCount);\\n\\n\\t\\tuint partStart = 0;\\n\\t\\tuint partIndex = 0;\\n\\t\\tfor (uint i = 0; i < strBytes.length; ++i) {\\n\\t\\t\\tif (strBytes[i] == delimiterBytes[0]) {\\n\\t\\t\\t\\tparts[partIndex] = substring(str, partStart, i);\\n\\t\\t\\t\\tpartStart = i + 1;\\n\\t\\t\\t\\tpartIndex++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Add the last part\\n\\t\\tparts[partIndex] = substring(str, partStart, strBytes.length);\\n\\n\\t\\treturn parts;\\n\\t}\\n\\n\\tfunction substring(\\n\\t\\tstring memory str,\\n\\t\\tuint startIndex,\\n\\t\\tuint endIndex\\n\\t) internal pure returns (string memory) {\\n\\t\\tbytes memory strBytes = bytes(str);\\n\\t\\trequire(\\n\\t\\t\\tstartIndex <= endIndex && endIndex <= strBytes.length,\\n\\t\\t\\t\\\"Invalid substring indices\\\"\\n\\t\\t);\\n\\n\\t\\tbytes memory result = new bytes(endIndex - startIndex);\\n\\t\\tfor (uint i = startIndex; i < endIndex; ++i) {\\n\\t\\t\\tresult[i - startIndex] = strBytes[i];\\n\\t\\t}\\n\\n\\t\\treturn string(result);\\n\\t}\\n\\n\\tfunction extractOrgIdFromElectionId(\\n\\t\\tstring memory _userElectionID\\n\\t) internal pure returns (string memory) {\\n\\t\\tbytes memory orgIdBytes = bytes(_userElectionID);\\n\\n\\t\\t// Split the input string at the hyphen ('-')\\n\\t\\tuint8 i = 0;\\n\\t\\twhile (i < orgIdBytes.length && orgIdBytes[i] != \\\"-\\\") {\\n\\t\\t\\t// ASCII code for hyphen '-'\\n\\t\\t\\t++i;\\n\\t\\t}\\n\\n\\t\\t// If a hyphen is found, extract the organization ID\\n\\t\\tif (i < orgIdBytes.length) {\\n\\t\\t\\tbytes memory extractedBytes = new bytes(i);\\n\\t\\t\\tfor (uint8 j = 0; j < i; ++j) {\\n\\t\\t\\t\\textractedBytes[j] = orgIdBytes[j];\\n\\t\\t\\t}\\n\\t\\t\\treturn string(extractedBytes);\\n\\t\\t}\\n\\n\\t\\treturn \\\"\\\";\\n\\t}\\n\\n\\tfunction concat(\\n\\t\\tstring memory _a,\\n\\t\\tstring memory _b\\n\\t) internal pure returns (string memory) {\\n\\t\\treturn string(abi.encodePacked(bytes(_a), bytes(_b)));\\n\\t}\\n}\\n\",\"keccak256\":\"0x502f8fde6cc04cd1b0ee935f1bdd9266d27628338ce0f3371e24f16966358efa\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60808060405234601757603a9081601d823930815050f35b600080fdfe600080fdfea26469706673582212207ba0fdf43c28472b94fab54cf3bb04eaaa21d0e64fcec50fd6bfe9f35f589db964736f6c634300081b0033",
  "deployedBytecode": "0x600080fdfea26469706673582212207ba0fdf43c28472b94fab54cf3bb04eaaa21d0e64fcec50fd6bfe9f35f589db964736f6c634300081b0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}