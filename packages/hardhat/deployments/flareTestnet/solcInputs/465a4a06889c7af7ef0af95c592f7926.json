{
  "language": "Solidity",
  "sources": {
    "contracts/Ultimate_VotreXSystemRC2B.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// pragma abicoder v2;\npragma solidity ^0.8.24;\n\nimport \"./UtilityLibrary.sol\";\n\ncontract TestCompleXA2B{\n\n    using UtilityLibrary for *;\n\n    constructor(){\n        VotreXOwnerAddress = msg.sender;\n        VotreXActivated = true;\n    }\n    bool private VotreXActivated;\n    address private previousVotreXOwnerAddress;\n    address private VotreXOwnerAddress;\n    bytes32 public VotreXOwnerName = keccak256(abi.encodePacked(\"ATom\"));\n    uint256 private organizationsCounter;\n    uint256 private VotreXUserCounter;\n    // uint256 private OrganizationPriceFee = 20 ether;\n    \n    mapping(string  => Organization) public organizationData;\n    mapping(address => ElectionAdmins) public admin;\n    mapping(address => Voter) public voters;\n    mapping(bytes32 => ElectionDetail) public electionInfo;\n    mapping(string  => ElectionResult) public electionResults;\n    mapping(bytes32 => mapping(address => bool)) public hasVoted;\n    mapping(bytes32 => bool) private electionExistanceChecks;\n    mapping(bytes16 => bool) private votersIDExists;\n    mapping(bytes32 => address[]) private votersList;\n    mapping(address => bool) private registeredAdmin;\n    mapping(string => bool) private registeredCandidate;\n    string[] private candidateList;\n\n    enum ElectionStatus {\n        Preparation,\n        Scheduled,\n        Started,\n        Finished\n    }\n\n    enum OrganizationType {\n        Organization,\n        Corporate\n    }\n\n    struct Organization {\n        OrganizationType orgType;\n        address electionAdminAddresses;\n        uint256 onPreparationElectionCounter;\n        uint256 activeElectionCounter;\n        uint256 archivedElectionCounter;\n        uint256 totalMembers;\n        bytes32 orgName;\n        string orgID;\n        bytes32[] electionIDs;\n        bytes32[] ElectionName;\n        ElectionStatus[] electionStatus;\n    }\n\n    struct ElectionAdmins {\n        bool isRegistered;\n        uint8 adminOrgCount;\n        bytes10 AdminVoterIDOrg1;\n        bytes10 AdminVoterIDOrg2;\n        address electionAdminAddress;\n        uint256 nextOrgCreationBlock;\n        bytes32 adminName;\n        string RegisteredOrgID1;\n        string RegisteredOrgID2;\n    }\n\n    struct ElectionResult {\n        bool isPruned;\n        address adminAddress;\n        uint256 waveNumber;\n        uint startTime;\n        uint endTime;\n        uint totalVoter;\n        bytes32 electionID;\n        bytes32 electionName;\n        bytes32 digitalSignature;\n        string registeredOrganization;\n        string electionWinner;\n        string signedBy;\n        CandidateDetail[] candidates;\n    }\n    \n    struct Voter{\n        bool isRegistered;\n        address VoterAddress;\n        bytes16 VoterIDOrg1;\n        bytes16 VoterIDOrg2;\n        string VoterName;\n        string RegisteredOrgID1;\n        string RegisteredOrgID2;\n        string[] participatedElectionEvents;\n    }\n\n    struct ElectionDetail{\n        ElectionStatus status;\n        uint8 candidateList;\n        bool isFinished;\n        bytes32 electionID;\n        bytes32 electionName;\n        uint startTime;\n        uint endTime;\n        string orgID;\n        uint256 totalParticipants;\n        uint256 waveNumber;\n        CandidateDetail[] candidates;\n    }\n\n    struct CandidateDetail{\n        uint8 candidateID;\n        uint256 candidateVoteCount;\n        string candidateName;\n    }\n\n    modifier onlyOrgAdmin(string memory _IDParameters) {\n        bool isAdminRegisteredForOrg = false;\n        if (\n            keccak256(abi.encodePacked(admin[msg.sender].RegisteredOrgID1))\n            ==\n            keccak256(abi.encodePacked(_IDParameters))\n            ||\n            keccak256(abi.encodePacked(admin[msg.sender].RegisteredOrgID2))\n            ==\n            keccak256(abi.encodePacked(_IDParameters))\n        ) {\n            isAdminRegisteredForOrg = true;\n        } else if (\n            bytes32(abi.encodePacked(admin[msg.sender].RegisteredOrgID1))\n            !=\n            bytes32(abi.encodePacked(_IDParameters))\n            ||\n            bytes32(abi.encodePacked(admin[msg.sender].RegisteredOrgID2))\n            !=\n            bytes32(abi.encodePacked(_IDParameters))\n        ) {\n            string memory orgID = UtilityLibrary.extractOrgId(_IDParameters);\n            isAdminRegisteredForOrg = true;\n\n        }\n\n        require(\n            isAdminRegisteredForOrg,\n            \"error:31a\"\n        );\n        _;\n    }\n\n    modifier onlyAuthorizedMember(string memory _userElectionID) {\n        string memory orgID = UtilityLibrary.extractOrgId(_userElectionID);\n\n        bool isAdminRegisteredForOrg = (\n            keccak256(abi.encodePacked(admin[msg.sender].RegisteredOrgID1))\n            ==\n            keccak256(abi.encodePacked(orgID))\n        )||(\n            keccak256(abi.encodePacked(admin[msg.sender].RegisteredOrgID2))\n            ==\n            keccak256(abi.encodePacked(orgID))\n        );\n\n        bool isVoterRegisteredForOrg = (\n            keccak256(abi.encodePacked(voters[msg.sender].RegisteredOrgID1))\n            ==\n            keccak256(abi.encodePacked(orgID))\n        )||(\n            keccak256(abi.encodePacked(voters[msg.sender].RegisteredOrgID2))\n            ==\n            keccak256(abi.encodePacked(orgID))\n        );\n\n        require(\n            isAdminRegisteredForOrg || isVoterRegisteredForOrg,\n            // error 31a = Incorrect access control\n            \"error:31a\"\n        );\n        _;\n    }\n\n    modifier canCreateOrg() {\n        require(\n            block.number >= admin[msg.sender].nextOrgCreationBlock,\n            // error 32 = error Block await for 2nd Admin Org Registration\n            \"error:32\"\n        );\n        _;\n    }\n\n    modifier onlyVotreXOwner() {\n        require(\n            msg.sender == VotreXOwnerAddress,\n            // error 31b = errror Owner access\n            \"error:31b\"\n        );\n        _;\n    }\n\n    modifier onlyWhenActivated() {\n        require(\n            VotreXActivated == true,\n            // error 33 = error system still disabled\n            \"error:33\"\n        );\n        _;\n    }\n\n    function CheckTokenETHBalance () external view onlyVotreXOwner returns (uint256) {\n        return (address(this).balance);\n    }\n\n    function changeSystemState() external onlyVotreXOwner{\n        if (VotreXActivated == false) {\n            VotreXActivated = true;\n        } else {\n            VotreXActivated = false;\n        }\n    }\n\n    // function setOrgPriceFee(uint256 _PriceinEther) external onlyVotreXOwner {\n    //     OrganizationPriceFee = _PriceinEther * 1 ether;\n    // }\n\n    // receive() external payable {\n\n    // }\n\n    function registerOrganization(\n        string memory _orgName,\n        string memory _orgID,\n        string memory _adminName,\n        OrganizationType _orgType\n    )\n        external\n        canCreateOrg\n        onlyWhenActivated\n    {\n        ElectionAdmins storage AdminInfo = admin[msg.sender];\n\n        // require(\n        //     msg.value == OrganizationPriceFee,\n        //     // error 34 = error wrong ether value being sent\n        //     \"error:34\"\n        // );\n\n        require(\n            organizationsCounter < 32000,\n            // error 35 = error limit reached\n            \"error:35\"\n        );\n\n        require(\n            bytes32(organizationData[_orgID].orgName).length > 0,\n            // error 36a = error incorrect null value\n            \"error:36a\"\n        );\n\n        require(\n            organizationData[_orgID].electionAdminAddresses == address(0),\n            // error 36a = error incorrect null value\n            \"error:36a\"\n        );\n\n        require(\n            UtilityLibrary.onlyAlphanumericCharacters(_orgID),\n            // error36b = Only Alpha Numeric character allowed\n            \"error:36b\"\n        );\n\n        require(\n            bytes(_orgName).length > 0,\n            // error 36a = error incorrect null value\n            \"error:36a\"\n        );\n\n        require(\n            bytes(_orgName).length < 32,\n            // error 36c = error character length limit\n\n            \"error:36c\"\n        );\n\n        require(\n            bytes(_adminName).length > 1\n        );\n\n        require(\n            bytes(_orgID).length == 3\n            ||\n            bytes(_orgID).length == 4\n            ||\n            bytes(_orgID).length == 5,\n            \"Org ID should 3 - 5 characters\"\n        );\n\n        require(\n            !UtilityLibrary.containsWhitespaceCheck(_orgID),\n            \"spaces in Org ID not allowed\"\n        );\n\n        require(\n            keccak256(abi.encodePacked(admin[msg.sender].RegisteredOrgID1))\n            !=\n            keccak256(abi.encodePacked(_orgID))\n            &&\n            keccak256(abi.encodePacked(admin[msg.sender].RegisteredOrgID2))\n            !=\n            keccak256(abi.encodePacked(_orgID)),\n            \"Admin is registered\"\n        );\n\n        Organization storage newOrg = organizationData[_orgID];\n        newOrg.orgID = _orgID;\n        newOrg.orgName = bytes32(abi.encodePacked(_orgName));\n        newOrg.orgType = _orgType;\n        newOrg.electionAdminAddresses = msg.sender;\n        newOrg.activeElectionCounter = 0;\n        newOrg.totalMembers = 1;\n\n        bytes10 UniqueAdminvoterID = bytes10(abi.encodePacked(_orgID, \"-\", \"Admin\"));\n\n        if (bytes(admin[msg.sender].RegisteredOrgID1).length == 0) {\n            admin[msg.sender].RegisteredOrgID1 = _orgID;\n            admin[msg.sender].AdminVoterIDOrg1 = UniqueAdminvoterID;\n        } else if (bytes(admin[msg.sender].RegisteredOrgID2).length == 0) {\n            admin[msg.sender].RegisteredOrgID2 = _orgID;\n            admin[msg.sender].AdminVoterIDOrg2 = UniqueAdminvoterID;\n        }\n\n        AdminInfo.electionAdminAddress = msg.sender;\n        AdminInfo.adminName = bytes32(abi.encodePacked(_adminName));\n        AdminInfo.isRegistered = true;\n        ++AdminInfo.adminOrgCount;\n\n        registeredAdmin[msg.sender] = true;\n        votersIDExists[UniqueAdminvoterID] = true;\n\n        AdminInfo.nextOrgCreationBlock = 50 + block.number;\n\n        ++organizationsCounter;\n        ++VotreXUserCounter;\n    }\n\n    \n\n    function registerVoter(\n        string memory _voterName,\n        string memory _orgID,\n        bytes32 uniqueVoterID\n    )\n        external\n        onlyWhenActivated\n    {\n        // require(\n        //     msg.value == (OrganizationPriceFee/2)\n        // );\n\n        Voter storage voter = voters[msg.sender];\n        // string memory uniqueVoterID = generateUniqueVoterID(_orgID);\n        bytes16 VoterID16 = bytes16(abi.encodePacked(uniqueVoterID));\n        // bytes32 orgIDs = keccak256(abi.encodePacked(_orgID));\n\n        require(\n            organizationData[_orgID].totalMembers < 5000,\n            \"Maximum member limit reached\"\n        );\n\n        require(\n            bytes(_voterName).length > 1,\n            \"Please fill Voter Name\"\n        );\n\n        require(\n            bytes(_voterName).length < 24,\n            \"Voter name limit is 24 characters\"\n        );\n\n        require(\n            keccak256(abi.encodePacked(voters[msg.sender].RegisteredOrgID1))\n            !=\n            keccak256(abi.encodePacked(_orgID))\n            &&\n            keccak256(abi.encodePacked(voters[msg.sender].RegisteredOrgID2))\n            !=\n            keccak256(abi.encodePacked(_orgID))\n            &&\n            !registeredAdmin[msg.sender],\n            \"Voter is registered in Org\"\n        );\n\n        require(\n            ElectionActiveCheck(_orgID) < 1,\n            \"Election in progress!\"\n        );\n\n        require(\n            bytes16(uniqueVoterID).length > 0\n        );\n\n        require(\n            bytes(organizationData[_orgID].orgID).length != 0,\n            \"Organization does not exist\"\n        );\n\n        if (bytes(voter.RegisteredOrgID1).length == 0) {\n            voter.RegisteredOrgID1 = _orgID;\n            voter.VoterIDOrg1 = VoterID16;\n        } else if (bytes(voter.RegisteredOrgID2).length == 0) {\n            voter.RegisteredOrgID2 = _orgID;\n            voter.VoterIDOrg2 = VoterID16;\n        }\n\n        voter.VoterAddress = msg.sender;\n        voter.VoterName = _voterName;\n        voter.participatedElectionEvents = new string[](0);\n        voter.isRegistered = true;\n        votersIDExists[VoterID16] = true;\n        ++VotreXUserCounter;\n        ++organizationData[_orgID].totalMembers;\n    }\n\n    function createElection(\n        string memory _orgID,\n        string memory _userElectionID,\n        string memory _electionName\n    )\n        external\n        onlyWhenActivated\n        onlyOrgAdmin(_orgID)\n    {\n        require(\n            bytes(organizationData[_orgID].orgID).length > 0\n        );\n\n        require(\n            bytes(_userElectionID).length > 1,\n            // error 36a = error incorrect null value\n            \"error 36a\"\n        \n        );\n\n        require(\n            bytes(_userElectionID).length < 5,\n            \"ID should < 5 characters\"\n        );\n\n        require(\n            bytes(_electionName).length > 1\n        );\n\n        require(\n            bytes(_electionName).length < 25,\n            \"Election name should < 25\"\n        );\n\n        require(\n            organizationData[_orgID].activeElectionCounter < 10,\n            \"Maximum events reached\"\n        );\n\n        bytes32 generatedElectionID = bytes32(abi.encodePacked(_orgID, \"-\", _userElectionID));\n        ElectionDetail storage newElection = electionInfo[generatedElectionID];\n\n        require(\n            !electionExistanceChecks[generatedElectionID],\n            \"Election ID exists\"\n        );\n\n        newElection.orgID = _orgID;\n        newElection.electionID = generatedElectionID;\n        newElection.electionName = bytes32(abi.encodePacked(_electionName));\n        newElection.candidateList = 0;\n        newElection.status = ElectionStatus.Preparation;\n        electionExistanceChecks[generatedElectionID] = true;\n        organizationData[_orgID].electionIDs.push(generatedElectionID);\n        organizationData[_orgID].ElectionName.push(bytes32(abi.encodePacked(_electionName)));\n        organizationData[_orgID].electionStatus.push(ElectionStatus.Preparation);\n        ++organizationData[_orgID].onPreparationElectionCounter;\n    }\n\n    function startElection(string memory _userElectionID) external onlyOrgAdmin(_userElectionID){\n        // error 36a = error incorrect null value\n        require(bytes(_userElectionID).length > 0, \"error:36a\");\n\n        bytes32 userElectionID = bytes32(abi.encodePacked(_userElectionID));\n        string memory orgIDs = UtilityLibrary.extractOrgId(_userElectionID);\n\n        ElectionDetail storage election = electionInfo[userElectionID];\n        require(bytes16(election.electionID).length > 0, \"Invalid election ID\");\n        require(election.status == ElectionStatus.Preparation, \"Election is not in preparation\");\n\n        election.startTime = 5 + block.timestamp;\n        election.status = ElectionStatus.Started;\n        ++election.waveNumber;\n        ++organizationData[orgIDs].activeElectionCounter;\n        --organizationData[orgIDs].onPreparationElectionCounter;\n        uint256 index = findElectionIndex(organizationData[orgIDs].electionIDs, userElectionID);\n        require(index < organizationData[orgIDs].electionIDs.length, \"Election not found\");\n        organizationData[orgIDs].electionStatus[index] = ElectionStatus.Started;\n    }\n\n    function findElectionIndex(bytes32[] storage array, bytes32 electionID) internal view returns (uint256) {\n        for (uint256 i = 0; i < array.length; i++) {\n            if (array[i] == electionID) {\n                return i;\n            }\n        }\n        revert(\"Election ID not found\");\n    }\n\n    function finishElection(\n        string memory _userElectionID,\n        bytes32 _dataHash,\n        bool isSingleWaveOrFinalStage,\n        uint256 threshold\n    ) external onlyOrgAdmin(_userElectionID) {\n        bytes32 packedElectionID = bytes32(abi.encodePacked(_userElectionID));\n        string memory orgIDs = UtilityLibrary.extractOrgId(_userElectionID);\n        bytes32 electionIdBytes = keccak256(abi.encodePacked(_userElectionID));\n        ElectionDetail storage elections = electionInfo[packedElectionID];\n        string memory adminName = getAdminName(msg.sender);\n\n        require(\n            bytes(_userElectionID).length > 0,\n            \"Invalid election ID\"\n        );\n\n        require(_dataHash.length > 0, \"Invalid data hash\");\n\n        require(\n            elections.totalParticipants > calculateValidElection(_userElectionID),\n            \"need 50% total member to finish\"\n        );\n\n        require(!elections.isFinished, \"Election finished\");\n        \n        require(\n            elections.status == ElectionStatus.Started,\n            \"Election is not started\"\n        );\n\n        if (isSingleWaveOrFinalStage == true)\n        {\n            // Kondisi jika hanya 2 kandidat tersisa\n            require(elections.candidates.length == 2, \"Single-wave requires exactly 2 candidates\");\n            string memory electionWinner = determineWinner(_userElectionID);\n            elections.endTime = 10 + block.timestamp;\n            elections.status = ElectionStatus.Finished;\n            elections.isFinished = true;\n\n            ElectionResult storage newelectionResult = electionResults[_userElectionID];\n            newelectionResult.isPruned = true;\n            newelectionResult.totalVoter = elections.totalParticipants;\n            newelectionResult.adminAddress = msg.sender;\n            newelectionResult.startTime = elections.startTime;\n            newelectionResult.endTime = elections.endTime;\n            newelectionResult.digitalSignature = _dataHash;\n            newelectionResult.registeredOrganization = elections.orgID;\n            newelectionResult.electionID = packedElectionID;\n            newelectionResult.waveNumber = elections.waveNumber;\n            newelectionResult.electionName = elections.electionName;\n            newelectionResult.electionWinner = electionWinner;\n            newelectionResult.signedBy = adminName;\n\n            for (uint i = 0; i < elections.candidates.length; i++) {\n                CandidateDetail memory candidate = elections.candidates[i];\n                newelectionResult.candidates.push(\n                    CandidateDetail({\n                        candidateID: candidate.candidateID,\n                        candidateName: candidate.candidateName,\n                        candidateVoteCount: candidate.candidateVoteCount\n                    })\n                );\n            }\n            \n            delete electionInfo[packedElectionID];\n            uint256 index = findElectionIndex(organizationData[orgIDs].electionIDs, packedElectionID);\n            organizationData[orgIDs].electionStatus[index] = ElectionStatus.Finished;\n            ++organizationData[orgIDs].archivedElectionCounter;\n            --organizationData[orgIDs].activeElectionCounter;\n        } else {\n            // Kondisi jika kandidat lebih dari 2, reset kandidat\n            require(elections.candidates.length > 2, \"More than 2 candidates required\");\n\n            for (uint256 i = 0; i < elections.candidates.length; ) {\n                if (elections.candidates[i].candidateVoteCount < threshold) {\n                    elections.candidates[i] = elections.candidates[elections.candidates.length - 1];\n                    elections.candidates.pop(); // Hapus kandidat terakhir\n                    elections.totalParticipants = 0;\n                } else {\n                    ++i;\n                }\n            }\n\n            // Reset suara kandidat yang tersisa\n            for (uint256 i = 0; i < elections.candidates.length; i++) {\n                elections.candidates[i].candidateVoteCount = 0;\n            }\n\n            // Reset status hasVoted untuk semua peserta\n            address[] storage voter = votersList[electionIdBytes];\n            require(voter.length > 0, \"No voters to reset\");\n\n            for (uint256 i = 0; i < voter.length; i++) {\n                hasVoted[electionIdBytes][voter[i]] = false;\n            }\n\n            // Debugging log untuk memastikan reset berjalan\n            for (uint256 i = 0; i < voter.length; i++) {\n                bool status = hasVoted[electionIdBytes][voter[i]];\n                emit LogResetVoter(voter[i], status); // Emit event untuk debugging\n            }\n\n            // Hapus daftar voters untuk tahap berikutnya\n            delete votersList[electionIdBytes];\n            ++elections.waveNumber;\n            elections.isFinished = false;\n\n            emit ElectionReset(_userElectionID);\n        }\n\n    }\n\n    // Event untuk menginformasikan frontend tentang reset pemilihan\n    event ElectionReset(string electionID);\n    event LogResetVoter(address voter, bool status);\n\n\n    function calculateValidElection(string memory _userElectionID)\n        private\n        view\n        returns (uint256)\n    {\n        string memory orgID = UtilityLibrary.extractOrgId(_userElectionID);\n        Organization storage OrgData = organizationData[orgID];\n        uint256 MIN_VOTES_PERCENTAGE = 1 + (OrgData.totalMembers / 2);\n\n        return MIN_VOTES_PERCENTAGE;\n    }\n\n\n    function getOwnerAddress() external view returns (address) {\n        return VotreXOwnerAddress;\n    }\n\n    function getOwnerName() external view returns (bytes32) {\n        return VotreXOwnerName;\n    }\n\n    function getTotalUser() external view returns (uint256) {\n        return VotreXUserCounter;\n    }\n\n    function getElectionListInOrg(string memory orgID)\n        public\n        view\n        returns (bytes32[] memory, bytes32[] memory, ElectionStatus[] memory)\n    {\n        Organization storage org = organizationData[orgID];\n        return (org.electionIDs, org.ElectionName, org.electionStatus);\n    }\n\n    function getAdminName(address adminAddress) private view returns (string memory) {\n        return string(abi.encodePacked(admin[adminAddress].adminName));\n    }\n\n\n    function vote(\n        string memory _userElectionID,\n        string memory _candidateName\n    )\n        external\n        onlyWhenActivated\n        onlyAuthorizedMember(_userElectionID)\n    {\n        bytes32 userElectionID = bytes32(abi.encodePacked(_userElectionID));\n        ElectionDetail storage election = electionInfo[userElectionID];\n        uint8 candidateIDs = uint8(election.candidates.length);\n        bytes32 electionIdBytes = keccak256(abi.encodePacked(_userElectionID));\n\n        // Pastikan nama kandidat tidak kosong\n        require(bytes(_candidateName).length > 0, \"Candidate name cannot be empty!\");\n        require(!hasVoted[electionIdBytes][msg.sender], \"Anda sudah memilih!\");\n        require(election.status == ElectionStatus.Started, \"Election is not in progress\");\n\n\n        bool candidateExists = false;\n\n        // Loop melalui array kandidat untuk mencari nama yang cocok\n        for (uint256 i = 0; i < election.candidates.length; i++) {\n            if (\n                keccak256(abi.encodePacked(election.candidates[i].candidateName))\n                ==\n                keccak256(abi.encodePacked(_candidateName))) {\n                // Jika kandidat ditemukan, tambahkan voteCount\n                election.candidates[i].candidateVoteCount += 1;\n                candidateExists = true;\n                break;\n                }\n        }\n\n        // Jika kandidat belum ada, tambahkan kandidat baru ke array\n        if (!candidateExists) {\n            CandidateDetail memory newCandidate = CandidateDetail({\n                candidateID: candidateIDs,\n                candidateName: _candidateName,\n                candidateVoteCount: 1\n            });\n            election.candidates.push(newCandidate);\n        }\n        hasVoted[electionIdBytes][msg.sender] = true;\n        votersList[electionIdBytes].push(msg.sender);\n        ++election.totalParticipants;\n    }\n\n    function getAllCandidates(string memory _userElectionID) public view returns (CandidateDetail[] memory) {\n        \n        bytes32 userElectionID = bytes32(abi.encodePacked(_userElectionID));\n        // Ambil detail pemilu berdasarkan ID\n        ElectionDetail storage election = electionInfo[userElectionID];\n\n        // Pastikan ada kandidat dalam pemilu\n        require(election.candidates.length > 0, \"No candidates found in this election!\");\n\n        // Kembalikan array kandidat dari pemilu\n        return election.candidates;\n    }\n\n    function isVotreXActivated() external onlyVotreXOwner view returns (bool) {\n        return VotreXActivated;\n    }\n\n    function getTotalOrganization() external virtual view returns (uint256) {\n        return organizationsCounter;\n    }\n\n    function getElectionInfo(string memory _userElectionID)\n        external\n        view\n        returns(\n            bytes32 electionID,\n            string memory electionName,\n            uint256 waveNumber,\n            uint256 totalCandidates,\n            uint8[] memory candidateIDs, // Added\n            string[] memory candidateNames,\n            uint256[] memory voteCounts,\n            uint256 totalParticipants,\n            ElectionStatus statusElection\n        )\n    {\n        bytes32 userElectionID = bytes32(abi.encodePacked(_userElectionID));\n\n        ElectionDetail storage election = electionInfo[userElectionID];\n        require(\n            bytes32(election.electionID).length > 0\n        );\n\n        electionID = election.electionID;\n        electionName = string(abi.encodePacked(election.electionName));\n        waveNumber = election.waveNumber;\n        totalCandidates = election.candidates.length;\n        candidateIDs = new uint8[](totalCandidates); // Initialized\n        candidateNames = new string[](totalCandidates);\n        voteCounts = new uint256[](totalCandidates);\n        totalParticipants = election.totalParticipants;\n        statusElection = electionInfo[userElectionID].status;\n\n        for (uint256 i = 0; i < totalCandidates; ++i) {\n            candidateIDs[i] = election.candidates[i].candidateID; // Added\n            candidateNames[i] = election.candidates[i].candidateName;\n            voteCounts[i] = election.candidates[i].candidateVoteCount;\n        }\n\n        return (\n            electionID,\n            electionName,\n            waveNumber,\n            totalCandidates,\n            candidateIDs,\n            candidateNames,\n            voteCounts,\n            totalParticipants,\n            statusElection\n        );\n    }\n\n    function getCandidateResult(string memory _electionID) \n        public \n        view \n        returns (\n            uint8[] memory candidateID,\n            string[] memory candidateName,\n            uint256[] memory candidateVoteCount\n        ) \n    {\n\n        uint totalCandidates = electionResults[_electionID].candidates.length;\n\n        uint8[] memory candidateIDs = new uint8[](totalCandidates);\n        string[] memory candidateNames = new string[](totalCandidates);\n        uint256[] memory candidateVoteCounts = new uint256[](totalCandidates);\n\n        for (uint i = 0; i < totalCandidates; i++) {\n            candidateIDs[i] = electionResults[_electionID].candidates[i].candidateID;\n            candidateNames[i] = electionResults[_electionID].candidates[i].candidateName;\n            candidateVoteCounts[i] = electionResults[_electionID].candidates[i].candidateVoteCount;\n        }\n\n        return (\n            candidateIDs,\n            candidateNames,\n            candidateVoteCounts\n        );\n    }\n\n    function getUserInfo() external view returns (\n        bool isRegistered,\n        bool isAdmin,\n        address userAddress,\n        string memory userName,\n        string[] memory registeredOrgList,\n        string[] memory voterIDList,\n        string[] memory participatedElectionEvents\n    ) {\n        userAddress = msg.sender;\n\n        if (admin[userAddress].isRegistered) {\n            ElectionAdmins storage adminInfo = admin[userAddress];\n            \n            string[] memory VoterRegisteredOrgList = new string[](2);\n            VoterRegisteredOrgList[0] = adminInfo.RegisteredOrgID1;\n            VoterRegisteredOrgList[1] = adminInfo.RegisteredOrgID2;\n\n            string[] memory VoterIDList = new string[](2);\n            VoterIDList[0] = string(abi.encodePacked(adminInfo.AdminVoterIDOrg1));\n            VoterIDList[1] = string(abi.encodePacked(adminInfo.AdminVoterIDOrg2));\n\n            return (\n                true,\n                true,\n                userAddress,\n                string(abi.encodePacked(adminInfo.adminName)),\n                VoterRegisteredOrgList,\n                VoterIDList,\n                new string[](0)\n            );\n\n        } else if (voters[userAddress].isRegistered) {\n            Voter storage voter = voters[userAddress];\n\n            string[] memory RegisteredOrgIDList = new string[](2);\n            RegisteredOrgIDList[0] = voter.RegisteredOrgID1;\n            RegisteredOrgIDList[1] = voter.RegisteredOrgID2;\n\n            string[] memory RegisteredVoterIDList = new string[](2);\n            RegisteredVoterIDList[0] = string(abi.encodePacked(voter.VoterIDOrg1));\n            RegisteredVoterIDList[1] = string(abi.encodePacked(voter.VoterIDOrg2));\n            return (\n                true,\n                false,\n                userAddress,\n                voter.VoterName,\n                RegisteredOrgIDList,\n                RegisteredVoterIDList,\n                voter.participatedElectionEvents\n            );\n        } else {\n            return (\n                false,\n                false,\n                userAddress,\n                \"\",\n                new string[](0),\n                new string[](0),\n                new string[](0)\n            );\n        }\n    }\n\n    function ElectionActiveCheck(string memory _orgID) private view returns (uint256) {\n\n        return organizationData[_orgID].activeElectionCounter;\n    \n    }\n\n    function hasParticipatedInElection(\n        address voterAddress,\n        bytes32 electionName\n    )\n        private\n        view\n        returns (bool)\n    {\n        Voter storage voter = voters[voterAddress];\n        for (uint i = 0; i < voter.participatedElectionEvents.length; ++i) {\n            if (\n                keccak256(abi.encodePacked(voter.participatedElectionEvents[i]))\n                ==\n                keccak256(abi.encodePacked(electionName))\n            ) {\n                return true; \n            }\n        }\n\n        return false; \n    }\n\n    function determineWinner(string memory _userElectionID) private view returns (string memory) {\n        bytes32 userElectionID = bytes32(abi.encodePacked(_userElectionID));\n        ElectionDetail storage election = electionInfo[userElectionID];\n        string memory winner = \"\";\n        uint256 maxVotes = 0;\n        for (uint8 i = 0; i < election.candidates.length; ++i) {\n            if (election.candidates[i].candidateVoteCount > maxVotes) {\n                maxVotes = election.candidates[i].candidateVoteCount;\n                winner = election.candidates[i].candidateName;\n            }\n        }\n\n        return winner;\n    }\n    \n    // function generateUniqueVoterID(string memory _orgID) public view returns (string memory) {\n    //     uint256 CurrentID = organizationData[_orgID].totalMembers;\n    //     uint256 nextID = ++CurrentID;\n\n    //     return string(abi.encodePacked(_orgID, \"-\", UtilityLibrary.uint2str(nextID)));\n    // }\n\n    function getOrgIDHash(string memory _orgID) external pure returns (bytes32) {\n        bytes32 orgIDHash = keccak256(abi.encodePacked(_orgID));\n\n        return (orgIDHash);\n    }\n}\n"
    },
    "contracts/UtilityLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.7.0;\n\nlibrary UtilityLibrary{\n\n    function extractOrgId(string memory _userElectionID) internal pure returns (string memory) {\n        string[] memory parts = UtilityLibrary.splitString(_userElectionID, \"-\");\n        require(parts.length > 0, \"Invalid custom election ID format\");\n\n        return parts[0];\n    }\n\n    function decodeBytes10(bytes10 data) internal pure returns (string memory) {\n        string memory decodedString = new string(10);\n        \n        assembly {\n            mstore(add(decodedString, 32), data)\n        }\n\n        return decodedString;\n    }\n    \n    function arrayContains(string[] storage array, string memory element) internal view returns (bool) {\n        for (uint256 i = 0; i < array.length; ++i) {\n            if (keccak256(abi.encodePacked(array[i])) == keccak256(abi.encodePacked(element))) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    function onlyAlphanumericCharacters(string memory _input) internal pure returns (bool) {\n        bytes memory b = bytes(_input);\n        for (uint i = 0; i < b.length; ++i) {\n            if (\n                !((uint8(b[i]) >= 48 && uint8(b[i]) <= 57) || // 0-9\n                (uint8(b[i]) >= 65 && uint8(b[i]) <= 90) || // A-Z\n                (uint8(b[i]) >= 97 && uint8(b[i]) <= 122))|| // a-z\n                uint8(b[i]) == 32 // Space\n            ){ \n                return false;\n            }\n        }\n        return true;\n    }\n\n    function appendToStringArray(string[] memory array, string memory newValue) internal pure returns (string[] memory) {\n        string[] memory newArray = new string[](array.length + 1);\n        \n        for (uint32 i = 0; i < array.length; ++i) {\n            newArray[i] = array[i];\n        }\n        \n        newArray[array.length] = newValue;\n        \n        return newArray;\n    }\n\n    function containsWhitespaceCheck(string memory _str) internal pure returns (bool) {\n        bytes memory strBytes = bytes(_str);\n\n        for (uint256 i = 0; i < strBytes.length; ++i) {\n            if (strBytes[i] == \" \") {\n                return true; \n            }\n        }\n\n        return false; \n    }\n\n\n    function uintToString(uint48 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n\n        uint48 temp = value;\n        uint48 length;\n        while (temp != 0) {\n            length++;\n            temp /= 10;\n        }\n\n        bytes memory buffer = new bytes(length);\n        uint48 i = length - 1;\n        while (value != 0) {\n            buffer[i] = bytes1(uint8(48 + value % 10));\n            value /= 10;\n            i--;\n        }\n\n        return string(buffer);\n    }\n\n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint j = _i;\n        uint len;\n        while (j != 0) {\n            ++len;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint k = len;\n        while (_i != 0) {\n            k = k-1;\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n\n\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n        return (keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b)));\n    }\n\n    function splitString(string memory str, string memory delimiter) internal pure returns (string[] memory) {\n        bytes memory strBytes = bytes(str);\n        bytes memory delimiterBytes = bytes(delimiter);\n\n        uint delimiterCount = 1;\n        for (uint i = 0; i < strBytes.length; ++i) {\n            if (strBytes[i] == delimiterBytes[0]) {\n                ++delimiterCount;\n            }\n        }\n\n        string[] memory parts = new string[](delimiterCount);\n\n        uint partStart = 0;\n        uint partIndex = 0;\n        for (uint i = 0; i < strBytes.length; ++i) {\n            if (strBytes[i] == delimiterBytes[0]) {\n                parts[partIndex] = substring(str, partStart, i);\n                partStart = i + 1;\n                partIndex++;\n            }\n        }\n\n        // Add the last part\n        parts[partIndex] = substring(str, partStart, strBytes.length);\n\n        return parts;\n    }\n\n    function substring(string memory str, uint startIndex, uint endIndex) internal pure returns (string memory) {\n        bytes memory strBytes = bytes(str);\n        require(startIndex <= endIndex && endIndex <= strBytes.length, \"Invalid substring indices\");\n\n        bytes memory result = new bytes(endIndex - startIndex);\n        for (uint i = startIndex; i < endIndex; ++i) {\n            result[i - startIndex] = strBytes[i];\n        }\n\n        return string(result);\n    }\n\n    function extractOrgIdFromElectionId(string memory _userElectionID) internal pure returns (string memory) {\n        bytes memory orgIdBytes = bytes(_userElectionID);\n\n        // Split the input string at the hyphen ('-')\n        uint8 i = 0;\n        while (i < orgIdBytes.length && orgIdBytes[i] != '-'){  // ASCII code for hyphen '-'\n            ++i;\n        }\n\n        // If a hyphen is found, extract the organization ID\n        if (i < orgIdBytes.length) {\n            bytes memory extractedBytes = new bytes(i);\n            for (uint8 j = 0; j < i; ++j) {\n                extractedBytes[j] = orgIdBytes[j];\n            }\n            return string(extractedBytes);\n        }\n\n        return \"\";\n    }\n\n    function concat(string memory _a, string memory _b) internal pure returns (string memory) {\n        return string(abi.encodePacked(bytes(_a), bytes(_b)));\n    }\n\n\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}