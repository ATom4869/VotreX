{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC5267.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.20;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC20} from \"../ERC20.sol\";\nimport {Context} from \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys a `value` amount of tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 value) public virtual {\n        _burn(_msgSender(), value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, deducting from\n     * the caller's allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `value`.\n     */\n    function burnFrom(address account, uint256 value) public virtual {\n        _spendAllowance(account, _msgSender(), value);\n        _burn(account, value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC20} from \"../ERC20.sol\";\nimport {Pausable} from \"../../../utils/Pausable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * IMPORTANT: This contract does not include public pause and unpause functions. In\n * addition to inheriting this contract, you must define both functions, invoking the\n * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate\n * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will\n * make the contract pause mechanism of the contract unreachable, and thus unusable.\n */\nabstract contract ERC20Pausable is ERC20, Pausable {\n    /**\n     * @dev See {ERC20-_update}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _update(address from, address to, uint256 value) internal virtual override whenNotPaused {\n        super._update(from, to, value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20Permit} from \"./IERC20Permit.sol\";\nimport {ERC20} from \"../ERC20.sol\";\nimport {ECDSA} from \"../../../utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"../../../utils/cryptography/EIP712.sol\";\nimport {Nonces} from \"../../../utils/Nonces.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712, Nonces {\n    bytes32 private constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Permit deadline has expired.\n     */\n    error ERC2612ExpiredSignature(uint256 deadline);\n\n    /**\n     * @dev Mismatched signature.\n     */\n    error ERC2612InvalidSigner(address signer, address owner);\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (block.timestamp > deadline) {\n            revert ERC2612ExpiredSignature(deadline);\n        }\n\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        if (signer != owner) {\n            revert ERC2612InvalidSigner(signer, owner);\n        }\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function nonces(address owner) public view virtual override(IERC20Permit, Nonces) returns (uint256) {\n        return super.nonces(owner);\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view virtual returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.20;\n\nimport {MessageHashUtils} from \"./MessageHashUtils.sol\";\nimport {ShortStrings, ShortString} from \"../ShortStrings.sol\";\nimport {IERC5267} from \"../../interfaces/IERC5267.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the {_domainSeparatorV4} function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable\n */\nabstract contract EIP712 is IERC5267 {\n    using ShortStrings for *;\n\n    bytes32 private constant TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {IERC-5267}.\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _name which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Name() internal view returns (string memory) {\n        return _name.toStringWithFallback(_nameFallback);\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _version which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Version() internal view returns (string memory) {\n        return _version.toStringWithFallback(_versionFallback);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\npragma solidity ^0.8.20;\n\nimport {Strings} from \"../Strings.sol\";\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Nonces.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Nonces.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides tracking nonces for addresses. Nonces will only increment.\n */\nabstract contract Nonces {\n    /**\n     * @dev The nonce used for an `account` is not the expected current nonce.\n     */\n    error InvalidAccountNonce(address account, uint256 currentNonce);\n\n    mapping(address account => uint256) private _nonces;\n\n    /**\n     * @dev Returns the next unused nonce for an address.\n     */\n    function nonces(address owner) public view virtual returns (uint256) {\n        return _nonces[owner];\n    }\n\n    /**\n     * @dev Consumes a nonce.\n     *\n     * Returns the current value and increments nonce.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256) {\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\n        // decremented or reset. This guarantees that the nonce never overflows.\n        unchecked {\n            // It is important to do x++ and not ++x here.\n            return _nonces[owner]++;\n        }\n    }\n\n    /**\n     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.\n     */\n    function _useCheckedNonce(address owner, uint256 nonce) internal virtual {\n        uint256 current = _useNonce(owner);\n        if (nonce != current) {\n            revert InvalidAccountNonce(owner, current);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ShortStrings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ShortStrings.sol)\n\npragma solidity ^0.8.20;\n\nimport {StorageSlot} from \"./StorageSlot.sol\";\n\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\n// | length  | 0x                                                              BB |\ntype ShortString is bytes32;\n\n/**\n * @dev This library provides functions to convert short memory strings\n * into a `ShortString` type that can be used as an immutable variable.\n *\n * Strings of arbitrary length can be optimized using this library if\n * they are short enough (up to 31 bytes) by packing them with their\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\n * fallback mechanism can be used for every other case.\n *\n * Usage example:\n *\n * ```solidity\n * contract Named {\n *     using ShortStrings for *;\n *\n *     ShortString private immutable _name;\n *     string private _nameFallback;\n *\n *     constructor(string memory contractName) {\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\n *     }\n *\n *     function name() external view returns (string memory) {\n *         return _name.toStringWithFallback(_nameFallback);\n *     }\n * }\n * ```\n */\nlibrary ShortStrings {\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a \"normal\" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using\n     * {setWithFallback}.\n     *\n     * WARNING: This will return the \"byte length\" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/Ultimate_VotreXSystemRC2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// pragma abicoder v2;\npragma solidity ^0.8.24;\n\nimport \"./UtilityLibrary.sol\";\nimport \"./VotreXTxInterface.sol\";\n\ncontract VotreXSystemA1{\n\n    using UtilityLibrary for *;\n\n    constructor(address _TXInterfaceAddress){\n        VotreXOwnerAddress = msg.sender;\n        VotreXActivated = false;\n        TxInterface = VotreXTXInterface(_TXInterfaceAddress);\n    }\n\n    VotreXTXInterface internal immutable TxInterface;\n    bool private VotreXActivated;\n    address private previousVotreXOwnerAddress;\n    address private VotreXOwnerAddress;\n    bytes32 public VotreXOwnerName = keccak256(abi.encodePacked(\"ATom\"));\n    uint256 private organizationsCounter;\n    uint256 private VotreXUserCounter;\n    uint256 private OrganizationPriceFee = 20 ether;\n    \n    mapping(string  => Organization) public organizationData;\n    mapping(address => ElectionAdmins) public admin;\n    mapping(address => Voter) public voters;\n    mapping(bytes32 => ElectionDetail) public electionInfo;\n    mapping(string  => ElectionResult) public electionResults;\n    mapping(bytes32 => bool) private electionExistanceChecks;\n    mapping(bytes16 => bool) private votersIDExists;\n    mapping(address => bool) private registeredAdmin;\n\n    enum ElectionStatus {\n        Preparation,\n        Scheduled,\n        Started,\n        Finished\n    }\n\n    enum OrganizationType {\n        Organization,\n        Corporate\n    }\n\n    struct Organization {\n        OrganizationType orgType;\n        address electionAdminAddresses;\n        uint256 onPreparationElectionCounter;\n        uint256 activeElectionCounter;\n        uint256 archivedElectionCounter;\n        uint256 totalMembers;\n        bytes32 orgName;\n        string orgID;\n        bytes32[] electionIDs;\n        bytes32[] ElectionName;\n        ElectionStatus[] electionStatus;\n    }\n\n    struct ElectionAdmins {\n        bool isRegistered;\n        uint8 adminOrgCount;\n        bytes10 AdminVoterIDOrg1;\n        bytes10 AdminVoterIDOrg2;\n        address electionAdminAddress;\n        uint256 nextOrgCreationBlock;\n        bytes32 adminName;\n        string RegisteredOrgID1;\n        string RegisteredOrgID2;\n    }\n\n    struct ElectionResult {\n        bool isPruned;\n        address adminAddress;\n        uint startTime;\n        uint endTime;\n        uint totalVoter;\n        bytes32 electionID;\n        bytes32 electionName;\n        bytes32 digitalSignature;\n        string registeredOrganization;\n        string electionWinner;\n        string signedBy;\n        CandidateDetail[] candidates;\n    }\n    \n    struct Voter{\n        bool isRegistered;\n        address VoterAddress;\n        bytes16 VoterIDOrg1;\n        bytes16 VoterIDOrg2;\n        string VoterName;\n        string RegisteredOrgID1;\n        string RegisteredOrgID2;\n        string[] participatedElectionEvents;\n    }\n\n    struct ElectionDetail{\n        ElectionStatus status;\n        uint8 candidateList;\n        bool isFinished;\n        bytes32 electionID;\n        bytes32 electionName;\n        uint startTime;\n        uint endTime;\n        string orgID;\n        uint256 totalParticipants;\n        CandidateDetail[] candidates;\n    }\n\n    struct CandidateDetail{\n        uint8 candidateID;\n        uint256 candidateVoteCount;\n        string candidateName;\n    }\n\n    modifier onlyOrgAdmin(string memory _IDParameters) {\n        bool isAdminRegisteredForOrg = false;\n        if (\n            keccak256(abi.encodePacked(admin[msg.sender].RegisteredOrgID1))\n            ==\n            keccak256(abi.encodePacked(_IDParameters))\n            ||\n            keccak256(abi.encodePacked(admin[msg.sender].RegisteredOrgID2))\n            ==\n            keccak256(abi.encodePacked(_IDParameters))\n        ) {\n            isAdminRegisteredForOrg = true;\n        } else if (\n            bytes32(abi.encodePacked(admin[msg.sender].RegisteredOrgID1))\n            !=\n            bytes32(abi.encodePacked(_IDParameters))\n            ||\n            bytes32(abi.encodePacked(admin[msg.sender].RegisteredOrgID2))\n            !=\n            bytes32(abi.encodePacked(_IDParameters))\n        ) {\n            string memory orgID = UtilityLibrary.extractOrgId(_IDParameters);\n            isAdminRegisteredForOrg = true;\n\n        }\n\n        require(\n            isAdminRegisteredForOrg,\n            \"error:31a\"\n        );\n        _;\n    }\n\n    modifier onlyAuthorizedMember(string memory _userElectionID) {\n        string memory orgID = UtilityLibrary.extractOrgId(_userElectionID);\n\n        bool isAdminRegisteredForOrg = (\n            keccak256(abi.encodePacked(admin[msg.sender].RegisteredOrgID1))\n            ==\n            keccak256(abi.encodePacked(orgID))\n        )||(\n            keccak256(abi.encodePacked(admin[msg.sender].RegisteredOrgID2))\n            ==\n            keccak256(abi.encodePacked(orgID))\n        );\n\n        bool isVoterRegisteredForOrg = (\n            keccak256(abi.encodePacked(voters[msg.sender].RegisteredOrgID1))\n            ==\n            keccak256(abi.encodePacked(orgID))\n        )||(\n            keccak256(abi.encodePacked(voters[msg.sender].RegisteredOrgID2))\n            ==\n            keccak256(abi.encodePacked(orgID))\n        );\n\n        require(\n            isAdminRegisteredForOrg || isVoterRegisteredForOrg,\n            // error 31a = Incorrect access control\n            \"error:31a\"\n        );\n        _;\n    }\n\n    modifier canCreateOrg() {\n        require(\n            block.number >= admin[msg.sender].nextOrgCreationBlock,\n            // error 32 = error Block await for 2nd Admin Org Registration\n            \"error:32\"\n        );\n        _;\n    }\n\n    modifier onlyVotreXOwner() {\n        require(\n            msg.sender == VotreXOwnerAddress,\n            // error 31b = errror Owner access\n            \"error:31b\"\n        );\n        _;\n    }\n\n    modifier onlyWhenActivated() {\n        require(\n            VotreXActivated == true,\n            // error 33 = error system still disabled\n            \"error:33\"\n        );\n        _;\n    }\n\n    function buyContract(string memory _YourName) public payable {\n        require(VotreXActivated == false);\n        // error 34 = error wrong ether value being sent\n        require(msg.value == 12 ether, \"error:34\");\n\n        previousVotreXOwnerAddress = VotreXOwnerAddress;\n        VotreXOwnerAddress = address(0);\n        VotreXOwnerName = keccak256(abi.encodePacked(_YourName));\n\n        payable(previousVotreXOwnerAddress).transfer(msg.value);\n\n        previousVotreXOwnerAddress = address(0);\n        VotreXOwnerAddress = msg.sender;\n    }\n\n    function CheckTokenBalance () external view onlyVotreXOwner returns (uint256) {\n        return TxInterface.checkBalance(address(this));\n    }\n\n    function CheckTokenETHBalance () external view onlyVotreXOwner returns (uint256) {\n        return (address(this).balance);\n    }\n\n    function changeSystemState() external onlyVotreXOwner{\n        if (VotreXActivated == false) {\n            VotreXActivated = true;\n        } else if (VotreXActivated == true) {\n            VotreXActivated = false;\n        }\n    }\n\n    function setOrgPriceFee(uint256 _PriceinEther) external onlyVotreXOwner {\n        OrganizationPriceFee = _PriceinEther * 1 ether;\n    }\n\n    receive() external payable {\n\n    }\n\n    function registerOrganization(\n        string memory _orgName,\n        string memory _orgID,\n        string memory _adminName,\n        OrganizationType _orgType\n    )\n        external\n        payable\n        canCreateOrg\n        onlyWhenActivated\n    {\n        uint8 VXTAmount = 5;\n        ElectionAdmins storage AdminInfo = admin[msg.sender];\n\n        require(\n            msg.value == OrganizationPriceFee,\n            // error 34 = error wrong ether value being sent\n            \"error:34\"\n        );\n\n        require(\n            organizationsCounter < 32000,\n            // error 35 = error limit reached\n            \"error:35\"\n        );\n\n        require(\n            bytes32(organizationData[_orgID].orgName).length > 0,\n            // error 36a = error incorrect null value\n            \"error:36a\"\n        );\n\n        require(\n            organizationData[_orgID].electionAdminAddresses == address(0),\n            // error 36a = error incorrect null value\n            \"error:36a\"\n        );\n\n        require(\n            UtilityLibrary.onlyAlphanumericCharacters(_orgID),\n            // error36b = Only Alpha Numeric character allowed\n            \"error:36b\"\n        );\n\n        require(\n            bytes(_orgName).length > 0,\n            // error 36a = error incorrect null value\n            \"error:36a\"\n        );\n\n        require(\n            bytes(_orgName).length < 32,\n            // error 36c = error character length limit\n\n            \"error:36c\"\n        );\n\n        require(\n            bytes(_adminName).length > 1\n        );\n\n        require(\n            bytes(_orgID).length == 3 || bytes(_orgID).length == 4,\n            \"Org ID should 3 or 4 characters\"\n        );\n\n        require(\n            !UtilityLibrary.containsWhitespaceCheck(_orgID),\n            \"spaces in Org ID not allowed\"\n        );\n\n        require(\n            keccak256(abi.encodePacked(admin[msg.sender].RegisteredOrgID1))\n            !=\n            keccak256(abi.encodePacked(_orgID))\n            &&\n            keccak256(abi.encodePacked(admin[msg.sender].RegisteredOrgID2))\n            !=\n            keccak256(abi.encodePacked(_orgID)),\n            \"Admin is registered\"\n        );\n\n        Organization storage newOrg = organizationData[_orgID];\n        newOrg.orgID = _orgID;\n        newOrg.orgName = bytes32(abi.encodePacked(_orgName));\n        newOrg.orgType = _orgType;\n        newOrg.electionAdminAddresses = msg.sender;\n        newOrg.activeElectionCounter = 0;\n        newOrg.totalMembers = 1;\n\n        bytes10 UniqueAdminvoterID = bytes10(abi.encodePacked(_orgID, \"-\", \"Admin\"));\n\n        if (bytes(admin[msg.sender].RegisteredOrgID1).length == 0) {\n            admin[msg.sender].RegisteredOrgID1 = _orgID;\n            admin[msg.sender].AdminVoterIDOrg1 = UniqueAdminvoterID;\n        } else if (bytes(admin[msg.sender].RegisteredOrgID2).length == 0) {\n            admin[msg.sender].RegisteredOrgID2 = _orgID;\n            admin[msg.sender].AdminVoterIDOrg2 = UniqueAdminvoterID;\n        }\n\n        AdminInfo.electionAdminAddress = msg.sender;\n        AdminInfo.adminName = bytes32(abi.encodePacked(_adminName));\n        AdminInfo.isRegistered = true;\n        ++AdminInfo.adminOrgCount;\n\n        registeredAdmin[msg.sender] = true;\n        votersIDExists[UniqueAdminvoterID] = true;\n\n        AdminInfo.nextOrgCreationBlock = 50 + block.number;\n\n        ++organizationsCounter;\n        ++VotreXUserCounter;\n\n        TxInterface.VotreXTx(msg.sender, VXTAmount);\n    }\n\n    \n\n    function registerVoter(\n        string memory _voterName,\n        string memory _orgID,\n        bytes32 uniqueVoterID\n    )\n        external\n        payable\n        onlyWhenActivated\n    {\n        require(\n            msg.value == (OrganizationPriceFee/2)\n        );\n\n        Voter storage voter = voters[msg.sender];\n        uint8 VXTAmount = 5;\n        // string memory uniqueVoterID = generateUniqueVoterID(_orgID);\n        bytes16 VoterID16 = bytes16(abi.encodePacked(uniqueVoterID));\n        // bytes32 orgIDs = keccak256(abi.encodePacked(_orgID));\n\n        require(\n            organizationData[_orgID].totalMembers < 5000,\n            \"Maximum member limit reached\"\n        );\n\n        require(\n            bytes(_voterName).length > 1,\n            \"Please fill Voter Name\"\n        );\n\n        require(\n            bytes(_voterName).length < 24,\n            \"Voter name limit is 24 characters\"\n        );\n\n        require(\n            keccak256(abi.encodePacked(voters[msg.sender].RegisteredOrgID1))\n            !=\n            keccak256(abi.encodePacked(_orgID))\n            &&\n            keccak256(abi.encodePacked(voters[msg.sender].RegisteredOrgID2))\n            !=\n            keccak256(abi.encodePacked(_orgID))\n            &&\n            !registeredAdmin[msg.sender],\n            \"Voter is registered in Org\"\n        );\n\n        require(\n            ElectionActiveCheck(_orgID) < 1,\n            \"Election in progress!\"\n        );\n\n        require(\n            bytes16(uniqueVoterID).length > 0\n        );\n\n        require(\n            bytes(organizationData[_orgID].orgID).length != 0,\n            \"Organization does not exist\"\n        );\n\n        if (bytes(voter.RegisteredOrgID1).length == 0) {\n            voter.RegisteredOrgID1 = _orgID;\n            voter.VoterIDOrg1 = VoterID16;\n        } else if (bytes(voter.RegisteredOrgID2).length == 0) {\n            voter.RegisteredOrgID2 = _orgID;\n            voter.VoterIDOrg2 = VoterID16;\n        }\n\n        voter.VoterAddress = msg.sender;\n        voter.VoterName = _voterName;\n        voter.participatedElectionEvents = new string[](0);\n        voter.isRegistered = true;\n        votersIDExists[VoterID16] = true;\n        ++VotreXUserCounter;\n        ++organizationData[_orgID].totalMembers;\n\n        TxInterface.VotreXTx(msg.sender, VXTAmount);\n    }\n\n    function createElection(\n        string memory _orgID,\n        string memory _userElectionID,\n        string memory _electionName,\n        uint8 _candidateCount\n    )\n        external\n        onlyWhenActivated\n        onlyOrgAdmin(_orgID)\n    {\n        require(\n            bytes(organizationData[_orgID].orgID).length > 0\n        );\n\n        require(\n            bytes(_userElectionID).length > 1,\n            // error 36a = error incorrect null value\n            \"error 36a\"\n        \n        );\n\n        require(\n            bytes(_userElectionID).length < 5,\n            \"ID should < 5 characters\"\n        );\n\n        require(\n            bytes(_electionName).length > 1\n        );\n\n        require(\n            bytes(_electionName).length < 25,\n            \"Election name should < 25\"\n        );\n\n        require(\n            organizationData[_orgID].activeElectionCounter < 10,\n            \"Maximum events reached\"\n        );\n\n        require(_candidateCount > 1, \"Minimum 2 candidates!\");\n\n        bytes32 generatedElectionID = bytes32(abi.encodePacked(_orgID, \"-\", _userElectionID));\n        ElectionDetail storage newElection = electionInfo[generatedElectionID];\n\n        require(\n            !electionExistanceChecks[generatedElectionID],\n            \"Election ID exists\"\n        );\n\n        newElection.orgID = _orgID;\n        newElection.electionID = generatedElectionID;\n        newElection.electionName = bytes32(abi.encodePacked(_electionName));\n        newElection.candidateList = _candidateCount;\n        newElection.status = ElectionStatus.Preparation;\n        electionExistanceChecks[generatedElectionID] = true;\n        organizationData[_orgID].electionIDs.push(generatedElectionID);\n        organizationData[_orgID].ElectionName.push(bytes32(abi.encodePacked(_electionName)));\n        organizationData[_orgID].electionStatus.push(ElectionStatus.Preparation);\n        ++organizationData[_orgID].onPreparationElectionCounter;\n    }\n\n    function startElection(string memory _userElectionID) external onlyOrgAdmin(_userElectionID){\n        // error 36a = error incorrect null value\n        require(bytes(_userElectionID).length > 0, \"error:36a\");\n\n        bytes32 userElectionID = bytes32(abi.encodePacked(_userElectionID));\n        string memory orgIDs = UtilityLibrary.extractOrgId(_userElectionID);\n\n        ElectionDetail storage election = electionInfo[userElectionID];\n        require(bytes16(election.electionID).length > 0, \"Invalid election ID\");\n        require(election.status == ElectionStatus.Preparation, \"Election is not in preparation\");\n        require(election.candidateList == election.candidates.length, \"Candidate Not full\");\n\n        election.startTime = 5 + block.timestamp;\n        election.status = ElectionStatus.Started;\n        ++organizationData[orgIDs].activeElectionCounter;\n        --organizationData[orgIDs].onPreparationElectionCounter;\n        uint256 index = findElectionIndex(organizationData[orgIDs].electionIDs, userElectionID);\n        require(index < organizationData[orgIDs].electionIDs.length, \"Election not found\");\n        organizationData[orgIDs].electionStatus[index] = ElectionStatus.Started;\n    }\n\n    function findElectionIndex(bytes32[] storage array, bytes32 electionID) internal view returns (uint256) {\n        for (uint256 i = 0; i < array.length; i++) {\n            if (array[i] == electionID) {\n                return i;\n            }\n        }\n        revert(\"Election ID not found\");\n    }\n\n    function finishElection(string memory _userElectionID, bytes32 _dataHash)\n        external\n        onlyOrgAdmin(_userElectionID)\n    {\n        bytes32 packedElectionID = bytes32(abi.encodePacked(_userElectionID));\n        ElectionDetail storage elections = electionInfo[packedElectionID];\n        string memory orgIDs = UtilityLibrary.extractOrgId(_userElectionID);\n        string memory adminName = getAdminName(msg.sender);\n        string memory electionWinner = determineWinner(_userElectionID);\n\n        require(\n            bytes(_userElectionID).length > 0,\n            \"Invalid election ID\"\n        );\n\n        require(\n            bytes(_userElectionID).length > 0,\n            \"Election ID can't be empty\"\n        );\n\n        require(\n            bytes32(electionInfo[packedElectionID].electionID).length > 0,\n            \"error:36a\"\n        );\n\n        require(\n            _dataHash.length > 0,\n            \"error:36a\"\n        );\n\n        require(!elections.isFinished, \"Election finished\");\n\n        require(\n            elections.status == ElectionStatus.Started,\n            \"Election is not started\"\n        );\n\n        require(\n            elections.totalParticipants > calculateValidElection(_userElectionID),\n            \"need 50% total member to finish\"\n        );\n\n        elections.endTime = 5 + block.timestamp;\n        elections.status = ElectionStatus.Finished;\n        elections.isFinished = true;\n\n        ElectionResult storage newelectionResult = electionResults[_userElectionID];\n        newelectionResult.isPruned = true;\n        newelectionResult.totalVoter = elections.totalParticipants;\n        newelectionResult.adminAddress = msg.sender;\n        newelectionResult.startTime = elections.startTime;\n        newelectionResult.endTime = elections.endTime;\n        newelectionResult.digitalSignature = _dataHash;\n        newelectionResult.registeredOrganization = elections.orgID;\n        newelectionResult.electionID = packedElectionID;\n        newelectionResult.electionName = elections.electionName;\n        newelectionResult.electionWinner = electionWinner;\n        newelectionResult.signedBy = adminName;\n\n        for (uint i = 0; i < elections.candidates.length; i++) {\n            CandidateDetail memory candidate = elections.candidates[i];\n            newelectionResult.candidates.push(\n                CandidateDetail({\n                    candidateID: candidate.candidateID,\n                    candidateName: candidate.candidateName,\n                    candidateVoteCount: candidate.candidateVoteCount\n                })\n            );\n        }\n\n        delete electionInfo[packedElectionID];\n        uint256 index = findElectionIndex(organizationData[orgIDs].electionIDs, packedElectionID);\n        organizationData[orgIDs].electionStatus[index] = ElectionStatus.Finished;\n        ++organizationData[orgIDs].archivedElectionCounter;\n        --organizationData[orgIDs].activeElectionCounter;\n    }\n\n\n    function calculateValidElection(string memory _userElectionID)\n        private\n        view\n        returns (uint256)\n    {\n        string memory orgID = UtilityLibrary.extractOrgId(_userElectionID);\n        Organization storage OrgData = organizationData[orgID];\n        uint256 MIN_VOTES_PERCENTAGE = 1 + (OrgData.totalMembers / 2);\n\n        return MIN_VOTES_PERCENTAGE;\n    }\n\n    function getOwnerAddress() external view returns (address) {\n        return VotreXOwnerAddress;\n    }\n\n    function getOwnerName() external view returns (bytes32) {\n        return VotreXOwnerName;\n    }\n\n    function getTotalUser() external view returns (uint256) {\n        return VotreXUserCounter;\n    }\n\n    function getElectionListInOrg(string memory orgID)\n        public\n        view\n        returns (bytes32[] memory, bytes32[] memory, ElectionStatus[] memory)\n    {\n        Organization storage org = organizationData[orgID];\n        return (org.electionIDs, org.ElectionName, org.electionStatus);\n    }\n\n    function getAdminName(address adminAddress) private view returns (string memory) {\n        return string(abi.encodePacked(admin[adminAddress].adminName));\n    }\n\n    function addCandidateDetail(\n        string memory _userElectionID,\n        string memory _candidateName\n    )\n        external\n        onlyOrgAdmin(_userElectionID)\n    {\n        bytes32 userElectionID = bytes32(abi.encodePacked(_userElectionID));\n        ElectionDetail storage election = electionInfo[userElectionID];\n\n        require(bytes(_userElectionID).length > 0);\n\n        require(\n            bytes32(electionInfo[userElectionID].electionID).length > 0,\n            // error 36a = error incorrect null value\n            \"error:36a\"\n        );\n\n        require(\n            election.candidates.length < election.candidateList,\n            \"Candidate limit reached\"\n        );\n\n        require(bytes(_candidateName).length > 0);\n\n        require(\n            bytes(_candidateName).length <= 24,\n            \"name limits 24 characters\"\n        );\n\n        require(\n            UtilityLibrary.onlyAlphanumericCharacters(_candidateName),\n            \"Candidate name can only contain alphabetical\"\n        );\n\n        uint8 candidateID = uint8(election.candidates.length);\n\n        election.candidates.push(\n            CandidateDetail({\n                candidateID: candidateID,\n                candidateName: _candidateName,\n                candidateVoteCount: 0\n            })\n        );\n    }\n\n    function vote(\n        string memory _userElectionID,\n        uint8 candidateID,\n        uint256 VotesAmount\n    )\n        external\n        onlyWhenActivated\n        onlyAuthorizedMember(_userElectionID)\n    {\n        bytes32 userElectionID = bytes32(abi.encodePacked(_userElectionID));\n        ElectionDetail storage election = electionInfo[userElectionID];\n        Voter storage voter = voters[msg.sender];\n        bytes32 electionName = election.electionName;\n        require(VotesAmount <= 5);\n        require(bytes(_userElectionID).length > 0, \"Election ID can't be empty\");\n        require(candidateID < election.candidates.length, \"Invalid candidate ID\");\n        require(election.status == ElectionStatus.Started, \"Election is not in progress\");\n        require(!hasParticipatedInElection(msg.sender, electionName), \"You already voted in this election\");\n\n        election.candidates[candidateID].candidateVoteCount += VotesAmount;\n        voter.participatedElectionEvents = UtilityLibrary.appendToStringArray(\n            voter.participatedElectionEvents,\n            string(abi.encodePacked(election.electionName))\n        );\n        ++election.totalParticipants;\n        TxInterface.VoteTx(msg.sender, VotesAmount);\n    }\n\n\n    function withdrawFees() external onlyVotreXOwner{\n        require(address(this).balance > 0, \"No FLR Balance in Contract\");\n        payable(VotreXOwnerAddress).transfer(address(this).balance);\n    }\n\n    function isVotreXActivated() external onlyVotreXOwner view returns (bool) {\n        return VotreXActivated;\n    }\n\n    function getRegistrationFee() external view returns (uint256){\n        return OrganizationPriceFee;\n    }\n\n    function getTotalOrganization() external virtual view returns (uint256) {\n        return organizationsCounter;\n    }\n\n    // function getCandidateDetail(\n    //     string memory _userElectionID,\n    //     string memory _candidateName\n    // )\n    //     external\n    //     view\n    //     returns(\n    //         string memory candidateName,\n    //         uint8 candidateID,\n    //         uint256 voteCount\n    //     )\n    // {\n    //     require(\n    //         bytes(_userElectionID).length > 0,\n    //         \"Election ID can't be empty\"\n    //     );\n\n    //     bytes32 userElectionID = bytes32(abi.encodePacked(_userElectionID));\n    //     ElectionDetail storage election = electionInfo[userElectionID];\n\n    //     for (uint32 i = 0; i < election.candidates.length; ++i) {\n    //         if (\n    //             keccak256(abi.encodePacked(election.candidates[i].candidateName))\n    //             ==\n    //             keccak256(abi.encodePacked(_candidateName))\n    //         ) {\n    //             return (\n    //                 election.candidates[i].candidateName,\n    //                 election.candidates[i].candidateID,\n    //                 election.candidates[i].candidateVoteCount\n    //             );\n    //         }\n    //     }\n\n    //     return ('', 0, 0);\n\n    // }\n\n    function getelectionInfo(string memory _userElectionID)\n        external\n        view\n        returns(\n            bytes32 electionID,\n            string memory electionName,\n            uint256 totalCandidates,\n            uint8[] memory candidateIDs, // Added\n            string[] memory candidateNames,\n            uint256[] memory voteCounts,\n            uint256 totalParticipants,\n            ElectionStatus statusElection\n        )\n    {\n        bytes32 userElectionID = bytes32(abi.encodePacked(_userElectionID));\n\n        ElectionDetail storage election = electionInfo[userElectionID];\n        require(\n            bytes32(election.electionID).length > 0\n        );\n\n        electionID = election.electionID;\n        electionName = string(abi.encodePacked(election.electionName));\n        totalCandidates = election.candidates.length;\n        candidateIDs = new uint8[](totalCandidates); // Initialized\n        candidateNames = new string[](totalCandidates);\n        voteCounts = new uint256[](totalCandidates);\n        statusElection = electionInfo[userElectionID].status;\n        totalParticipants = election.totalParticipants;\n\n        for (uint256 i = 0; i < totalCandidates; ++i) {\n            candidateIDs[i] = election.candidates[i].candidateID; // Added\n            candidateNames[i] = election.candidates[i].candidateName;\n            voteCounts[i] = election.candidates[i].candidateVoteCount;\n        }\n\n        return (\n            electionID,\n            electionName,\n            totalCandidates,\n            candidateIDs,\n            candidateNames,\n            voteCounts,\n            totalParticipants,\n            statusElection\n        );\n    }\n\n    function getCandidateResult(string memory _electionID) \n        public \n        view \n        returns (\n            uint8[] memory candidateID,\n            string[] memory candidateName,\n            uint256[] memory candidateVoteCount\n        ) \n    {\n\n        uint totalCandidates = electionResults[_electionID].candidates.length;\n\n        uint8[] memory candidateIDs = new uint8[](totalCandidates);\n        string[] memory candidateNames = new string[](totalCandidates);\n        uint256[] memory candidateVoteCounts = new uint256[](totalCandidates);\n\n        for (uint i = 0; i < totalCandidates; i++) {\n            candidateIDs[i] = electionResults[_electionID].candidates[i].candidateID;\n            candidateNames[i] = electionResults[_electionID].candidates[i].candidateName;\n            candidateVoteCounts[i] = electionResults[_electionID].candidates[i].candidateVoteCount;\n        }\n\n        return (\n            candidateIDs,\n            candidateNames,\n            candidateVoteCounts\n        );\n    }\n\n    function getUserInfo() external view returns (\n        bool isRegistered,\n        bool isAdmin,\n        address userAddress,\n        string memory userName,\n        string[] memory registeredOrgList,\n        string[] memory voterIDList,\n        string[] memory participatedElectionEvents\n    ) {\n        userAddress = msg.sender;\n\n        if (admin[userAddress].isRegistered) {\n            ElectionAdmins storage adminInfo = admin[userAddress];\n            \n            string[] memory VoterRegisteredOrgList = new string[](2);\n            VoterRegisteredOrgList[0] = adminInfo.RegisteredOrgID1;\n            VoterRegisteredOrgList[1] = adminInfo.RegisteredOrgID2;\n\n            string[] memory VoterIDList = new string[](2);\n            VoterIDList[0] = string(abi.encodePacked(adminInfo.AdminVoterIDOrg1));\n            VoterIDList[1] = string(abi.encodePacked(adminInfo.AdminVoterIDOrg2));\n\n            return (\n                true,\n                true,\n                userAddress,\n                string(abi.encodePacked(adminInfo.adminName)),\n                VoterRegisteredOrgList,\n                VoterIDList,\n                new string[](0)\n            );\n\n        } else if (voters[userAddress].isRegistered) {\n            Voter storage voter = voters[userAddress];\n\n            string[] memory RegisteredOrgIDList = new string[](2);\n            RegisteredOrgIDList[0] = voter.RegisteredOrgID1;\n            RegisteredOrgIDList[1] = voter.RegisteredOrgID2;\n\n            string[] memory RegisteredVoterIDList = new string[](2);\n            RegisteredVoterIDList[0] = string(abi.encodePacked(voter.VoterIDOrg1));\n            RegisteredVoterIDList[1] = string(abi.encodePacked(voter.VoterIDOrg2));\n            return (\n                true,\n                false,\n                userAddress,\n                voter.VoterName,\n                RegisteredOrgIDList,\n                RegisteredVoterIDList,\n                voter.participatedElectionEvents\n            );\n        } else {\n            return (\n                false,\n                false,\n                userAddress,\n                \"\",\n                new string[](0),\n                new string[](0),\n                new string[](0)\n            );\n        }\n    }\n\n    function ElectionActiveCheck(string memory _orgID) private view returns (uint256) {\n\n        return organizationData[_orgID].activeElectionCounter;\n    \n    }\n\n    function hasParticipatedInElection(\n        address voterAddress,\n        bytes32 electionName\n    )\n        private\n        view\n        returns (bool)\n    {\n        Voter storage voter = voters[voterAddress];\n        for (uint i = 0; i < voter.participatedElectionEvents.length; ++i) {\n            if (\n                keccak256(abi.encodePacked(voter.participatedElectionEvents[i]))\n                ==\n                keccak256(abi.encodePacked(electionName))\n            ) {\n                return true; \n            }\n        }\n\n        return false; \n    }\n\n    function determineWinner(string memory _userElectionID) private view returns (string memory) {\n        bytes32 userElectionID = bytes32(abi.encodePacked(_userElectionID));\n        ElectionDetail storage election = electionInfo[userElectionID];\n        string memory winner = \"\";\n        uint256 maxVotes = 0;\n        for (uint8 i = 0; i < election.candidates.length; ++i) {\n            if (election.candidates[i].candidateVoteCount > maxVotes) {\n                maxVotes = election.candidates[i].candidateVoteCount;\n                winner = election.candidates[i].candidateName;\n            }\n        }\n\n        return winner;\n    }\n    \n    // function generateUniqueVoterID(string memory _orgID) public view returns (string memory) {\n    //     uint256 CurrentID = organizationData[_orgID].totalMembers;\n    //     uint256 nextID = ++CurrentID;\n\n    //     return string(abi.encodePacked(_orgID, \"-\", UtilityLibrary.uint2str(nextID)));\n    // }\n\n    function getOrgIDHash(string memory _orgID) external pure returns (bytes32) {\n        bytes32 orgIDHash = keccak256(abi.encodePacked(_orgID));\n\n        return (orgIDHash);\n    }\n}\n"
    },
    "contracts/UtilityLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.7.0;\n\nlibrary UtilityLibrary{\n\n    function extractOrgId(string memory _userElectionID) internal pure returns (string memory) {\n        string[] memory parts = UtilityLibrary.splitString(_userElectionID, \"-\");\n        require(parts.length > 0, \"Invalid custom election ID format\");\n\n        return parts[0];\n    }\n\n    function decodeBytes10(bytes10 data) internal pure returns (string memory) {\n        string memory decodedString = new string(10);\n        \n        assembly {\n            mstore(add(decodedString, 32), data)\n        }\n\n        return decodedString;\n    }\n    \n    function arrayContains(string[] storage array, string memory element) internal view returns (bool) {\n        for (uint256 i = 0; i < array.length; ++i) {\n            if (keccak256(abi.encodePacked(array[i])) == keccak256(abi.encodePacked(element))) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    function onlyAlphanumericCharacters(string memory _input) internal pure returns (bool) {\n        bytes memory b = bytes(_input);\n        for (uint i = 0; i < b.length; ++i) {\n            if (!((uint8(b[i]) >= 48 && uint8(b[i]) <= 57) || // 0-9\n                (uint8(b[i]) >= 65 && uint8(b[i]) <= 90) || // A-Z\n                (uint8(b[i]) >= 97 && uint8(b[i]) <= 122))) { // a-z\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function appendToStringArray(string[] memory array, string memory newValue) internal pure returns (string[] memory) {\n        string[] memory newArray = new string[](array.length + 1);\n        \n        for (uint32 i = 0; i < array.length; ++i) {\n            newArray[i] = array[i];\n        }\n        \n        newArray[array.length] = newValue;\n        \n        return newArray;\n    }\n\n    function containsWhitespaceCheck(string memory _str) internal pure returns (bool) {\n        bytes memory strBytes = bytes(_str);\n\n        for (uint256 i = 0; i < strBytes.length; ++i) {\n            if (strBytes[i] == \" \") {\n                return true; \n            }\n        }\n\n        return false; \n    }\n\n\n    function uintToString(uint48 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n\n        uint48 temp = value;\n        uint48 length;\n        while (temp != 0) {\n            length++;\n            temp /= 10;\n        }\n\n        bytes memory buffer = new bytes(length);\n        uint48 i = length - 1;\n        while (value != 0) {\n            buffer[i] = bytes1(uint8(48 + value % 10));\n            value /= 10;\n            i--;\n        }\n\n        return string(buffer);\n    }\n\n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint j = _i;\n        uint len;\n        while (j != 0) {\n            ++len;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint k = len;\n        while (_i != 0) {\n            k = k-1;\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n\n\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n        return (keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b)));\n    }\n\n    function splitString(string memory str, string memory delimiter) internal pure returns (string[] memory) {\n        bytes memory strBytes = bytes(str);\n        bytes memory delimiterBytes = bytes(delimiter);\n\n        uint delimiterCount = 1;\n        for (uint i = 0; i < strBytes.length; ++i) {\n            if (strBytes[i] == delimiterBytes[0]) {\n                ++delimiterCount;\n            }\n        }\n\n        string[] memory parts = new string[](delimiterCount);\n\n        uint partStart = 0;\n        uint partIndex = 0;\n        for (uint i = 0; i < strBytes.length; ++i) {\n            if (strBytes[i] == delimiterBytes[0]) {\n                parts[partIndex] = substring(str, partStart, i);\n                partStart = i + 1;\n                partIndex++;\n            }\n        }\n\n        // Add the last part\n        parts[partIndex] = substring(str, partStart, strBytes.length);\n\n        return parts;\n    }\n\n    function substring(string memory str, uint startIndex, uint endIndex) internal pure returns (string memory) {\n        bytes memory strBytes = bytes(str);\n        require(startIndex <= endIndex && endIndex <= strBytes.length, \"Invalid substring indices\");\n\n        bytes memory result = new bytes(endIndex - startIndex);\n        for (uint i = startIndex; i < endIndex; ++i) {\n            result[i - startIndex] = strBytes[i];\n        }\n\n        return string(result);\n    }\n\n    function extractOrgIdFromElectionId(string memory _userElectionID) internal pure returns (string memory) {\n        bytes memory orgIdBytes = bytes(_userElectionID);\n\n        // Split the input string at the hyphen ('-')\n        uint8 i = 0;\n        while (i < orgIdBytes.length && orgIdBytes[i] != '-'){  // ASCII code for hyphen '-'\n            ++i;\n        }\n\n        // If a hyphen is found, extract the organization ID\n        if (i < orgIdBytes.length) {\n            bytes memory extractedBytes = new bytes(i);\n            for (uint8 j = 0; j < i; ++j) {\n                extractedBytes[j] = orgIdBytes[j];\n            }\n            return string(extractedBytes);\n        }\n\n        return \"\";\n    }\n\n    function concat(string memory _a, string memory _b) internal pure returns (string memory) {\n        return string(abi.encodePacked(bytes(_a), bytes(_b)));\n    }\n\n\n}"
    },
    "contracts/VotreXDex.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\nimport \"./VotreXTxInterface.sol\";\nimport \"./SafeMath.sol\";\n\ncontract VotreXDex {\n    using SafeMath for uint256;\n\n    constructor(address _intefaceAddress){\n        vxtInterface = VotreXTXInterface(_intefaceAddress);\n        ContractOwner = msg.sender;\n    }\n\n    VotreXTXInterface public immutable vxtInterface;\n    address public immutable ContractOwner;\n    uint256 public VXPriceRequested;\n    uint256 private FLRPricePoint;\n\n    mapping(address => uint256) public allowances;\n\n    event BuyVXTEvent (address indexed Requester,  uint256 FLRSent, uint256 VXTAmount);\n\n    modifier onlyOwner() {\n        require(msg.sender == ContractOwner, \"Caller is not a staker\");\n        _;\n    }\n\n    function addVXTPricingFLR(uint256 _flrPrice) public {\n        uint256 PricingConversion = _flrPrice * 1 ether;\n        FLRPricePoint = PricingConversion;\n    }\n\n    function approveDeX(uint256 amount) external onlyOwner {\n        require(msg.sender != address(0), \"DeX Address not set\");\n        vxtInterface.approveDeX(amount);\n        allowances[address(this)] = amount * 10 ** 18;\n    }\n\n    function checkFLR(uint256 _FLRAmount) public pure returns(uint256) {\n        uint256 VXT = _FLRAmount * 1 ether;\n\n        return VXT;\n    }\n\n    function convertToVXT(uint256 _VXTAmount) public pure returns(uint256) {\n        uint256 VXT = _VXTAmount.mul(10**18);\n\n        return VXT;\n    }\n\n    function GetVXTtoFLRPrice() public view returns(uint256) {\n\n        return FLRPricePoint;\n    }\n\n    function calculateReqPricesFLR(uint256 ETHAmount) public view returns (uint256 FLRAmount, uint256 VXTAmount) {\n        uint256 SentFLR = ETHAmount.mul(1 ether);\n        uint256 vxtCheckout = SentFLR.div(FLRPricePoint);\n        uint256 vxtNominal = vxtCheckout;\n\n        return (SentFLR, vxtNominal);\n    }\n\n    receive() external payable {\n        // emit Received(msg.sender, msg.value);\n    }\n\n    function BuyVXT() external payable {\n        uint256 SentFLR = msg.value.mul(1 ether);\n        uint256 vxtCheckout = SentFLR.div(FLRPricePoint);\n\n        require(msg.value > FLRPricePoint.div(2), \"Not sending at minimum reqirement\");\n        require(msg.value > 0, \"Ether value can't 0\");\n        \n        vxtInterface.VotreXTx(msg.sender, vxtCheckout);\n        allowances[msg.sender] = vxtCheckout;\n\n        emit BuyVXTEvent(msg.sender, msg.value, vxtCheckout);\n    }\n\n    function withdrawBalance() external onlyOwner{\n        require(address(this).balance != 0 ether, \"No FLR Left\");\n        uint256 withdrawalValue = address(this).balance;\n        payable(ContractOwner).transfer(withdrawalValue);\n    }\n\n    function CheckTokenBalance () external view onlyOwner returns (uint256) {\n        uint256 contractBalance = vxtInterface.checkBalance(address(this));\n        return contractBalance;\n    }\n    \n    function withdrawToken() external onlyOwner{\n        uint256 contractBalance = vxtInterface.checkBalance(address(this));\n        require(contractBalance > 0, \"No Token left\");\n        vxtInterface.VotreXTx(payable(msg.sender), contractBalance);\n    }\n\n\n}\n"
    },
    "contracts/VotreXStaker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\nimport \"./VotreXToken.sol\";\nimport \"./VotreXTxInterface.sol\";\nimport \"./SafeMath.sol\";\n\ncontract VotreXStake {\n    using SafeMath for uint256;\n\n    constructor(address _intefaceAddress){\n        VXInterface = VotreXTXInterface(_intefaceAddress);\n        Owner = msg.sender;\n    }\n\n    VotreXTXInterface private VXInterface;\n\n    uint8 private constant STAKE_REWARD_PERCENTAGE = 5;\n    uint256 private constant EPOCH_DURATION = 15 minutes;\n\n    address private immutable Owner;\n    address private Automation;\n    address[] private Stakeraddress;\n\n    uint256 private totalStake;\n    uint256 private sharedRewards;\n    uint256 private totalPrintToken;\n    uint256 private accumulativePrintedToken;\n    uint256 private totalInitialRewards;\n\n    mapping(address => StakerStorage) public stakerInfo;\n    mapping(address => uint256) public allowances;\n\n\n    struct StakerStorage{\n        address StakerAddress;\n        uint256 StakingValue;\n        uint256 initialReward;\n        uint256 accumulativeReward;\n        uint256 totalPrintedToken;\n        uint256 PrintValue;\n        uint256 startStakingTime;\n        uint256 rewardTime;\n    }\n\n    event Staked(\n        address indexed staker,\n        uint256 stakeValue,\n        uint256 rewardPercentage,\n        uint256 rewardValue,\n        uint256 StartTime,\n        uint256 NextRewardTime\n    );\n\n    event TokenPrinted(\n        address indexed Destination,\n        uint256 printedValue\n    );\n\n    event Unstaked(\n        address indexed staker,\n        uint256 stakeValueTaken\n    );\n\n    modifier onlyStaker() {\n        require(msg.sender == stakerInfo[msg.sender].StakerAddress, \"Caller is not a staker\");\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == Owner, \"Caller is not Owner\");\n        _;\n    }\n\n    modifier onlyAuthorized() {\n        require(\n            msg.sender == Owner\n            ||\n            msg.sender == Automation\n            ||\n            msg.sender == address(this),\n            \"Caller is not an Authorized\"\n        );\n        _;\n    }\n\n    function setNewInterfaceAddress (address _interfaceAddress) external onlyOwner{\n        require(\n            _interfaceAddress != address(VXInterface),\n            \"Registered Interface\"\n        );\n\n        require(\n            _interfaceAddress != address(0),\n            \"Invalid contract address\"\n        );\n\n        VXInterface = VotreXTXInterface(_interfaceAddress);\n    }\n\n    function authorizeAutomation(address _AutomationAddress) public onlyOwner{\n        Automation = _AutomationAddress;\n    }\n\n    function approveStaking(uint256 amount) external onlyOwner {\n        require(msg.sender != address(0), \"Invalid Address\");\n        VXInterface.approveStaking(amount);\n        allowances[address(this)] = amount * 10 ** 18;\n    }\n\n    function CheckTokenBalance() external view onlyOwner returns (uint256) {\n        uint256 cotractBalance = VXInterface.checkBalance(address(this));\n        return cotractBalance;\n    }\n    \n    function withdrawTokentoOwner() external onlyOwner {\n        uint256 contractBalance = VXInterface.checkBalance(address(this));\n        uint256 withdrawalValue = contractBalance - totalStake;\n        uint256 withdrawalsLimit = totalStake;\n        require(totalPrintToken > 0, \"Token is empty\");\n        require(contractBalance > withdrawalsLimit, \"Withdrawal Limit Reached\");\n\n        VXInterface.VotreXTx(msg.sender, withdrawalValue);\n    }\n\n    function withdrawPrintedTokento(address _destination) external onlyOwner{\n        uint256 withdrawalValue = accumulativePrintedToken - totalInitialRewards;\n        uint256 contractBalance = VXInterface.checkBalance(address(this));\n        uint256 withdrawalsLimit = totalStake;\n        require(totalPrintToken > 0, \"Token is empty\");\n        require(contractBalance > withdrawalsLimit, \"Withdrawal Limit Reached\");\n\n        VXInterface.VotreXTx(_destination, withdrawalValue);\n    }\n\n    function stake(uint256 stakeVXTValue) public {\n        require(stakeVXTValue > 0, \"Stake value must be greater than 0\");\n        require(stakeVXTValue > 500, \"Minimum stake is 500 VXT\");\n        require(stakeVXTValue < 4000000, \"Maximum stake is 4.000.0000 VXT\");\n        require(stakerInfo[msg.sender].StakingValue == 0, \"You already on staked phase\");\n\n        uint256 stakeValue = stakeVXTValue * 10**18;\n        uint256 startTime = 10 seconds+block.timestamp;\n        uint256 nextRewardTime = calculateNextTimeReward(startTime);\n        uint256 rewardValue = calculateRewardValue(stakeValue);\n        uint256 PrintValue = calculatePrintValue(stakeValue);\n\n        VXInterface.Stake(true, msg.sender, stakeValue);\n\n        stakerInfo[msg.sender] = StakerStorage(\n            msg.sender,\n            stakeValue,\n            rewardValue,\n            0,\n            0,\n            PrintValue,\n            startTime,\n            nextRewardTime\n        );\n\n        totalPrintToken += PrintValue;\n        Stakeraddress.push(msg.sender);\n        totalStake += stakeValue;\n        totalInitialRewards += rewardValue;\n        emit Staked(\n            msg.sender,\n            stakeValue,\n            STAKE_REWARD_PERCENTAGE,\n            stakerInfo[msg.sender].initialReward,\n            startTime,\n            nextRewardTime\n        );\n    }\n\n    function unstake() public onlyStaker {\n        uint256 initialStake = stakerInfo[msg.sender].StakingValue;\n        require(initialStake > 0, \"No stake to unstake\");\n\n        VXInterface.Stake(false, msg.sender, initialStake);\n\n        uint256 stakerIndex = findStakerIndex(msg.sender);\n        require(stakerIndex < Stakeraddress.length, \"Staker not found\");\n\n        if (stakerIndex < Stakeraddress.length - 1) {\n            Stakeraddress[stakerIndex] = Stakeraddress[Stakeraddress.length - 1];\n        }\n        Stakeraddress.pop();\n        totalStake -= initialStake;\n        sharedRewards -= stakerInfo[msg.sender].initialReward;\n        totalPrintToken -= stakerInfo[msg.sender].PrintValue;\n        accumulativePrintedToken -= stakerInfo[msg.sender].accumulativeReward;\n        totalInitialRewards -= stakerInfo[msg.sender].initialReward;\n\n        delete stakerInfo[msg.sender].StakerAddress;\n        delete stakerInfo[msg.sender].StakingValue;\n        delete stakerInfo[msg.sender].initialReward;\n        delete stakerInfo[msg.sender].accumulativeReward;\n        delete stakerInfo[msg.sender].totalPrintedToken;\n        delete stakerInfo[msg.sender].PrintValue;\n        delete stakerInfo[msg.sender].startStakingTime;\n        delete stakerInfo[msg.sender].rewardTime;\n\n        emit Unstaked(msg.sender, initialStake);\n    }\n\n    function checkTotalStakes() external view returns (uint256) {\n\n        return totalStake;\n    }\n\n    function checksharedRewards() external view returns (uint256) {\n\n        return sharedRewards;\n    }\n\n    function checkTotalPrintToken() external view returns (uint256) {\n\n        return totalPrintToken;\n    }\n\n    function checkTotalInitialRewards() external view returns (uint256) {\n\n        return totalInitialRewards;\n    }\n\n    function findStakerIndex(address stakerAddress) internal view returns (uint256) {\n        for (uint256 i = 0; i < Stakeraddress.length; i++) {\n            if (Stakeraddress[i] == stakerAddress) {\n                return i;\n            }\n        }\n        return Stakeraddress.length;\n    }\n\n    function distributeRewards() external onlyAuthorized {\n        address[] memory stakersToReward = filterStakers();\n\n        require(stakersToReward.length > 0, \"No staker to reward\");\n\n        for (uint256 i = 0; i < stakersToReward.length; i++) {\n            address staker = stakersToReward[i];\n            uint256 PrintedToken = stakerInfo[staker].PrintValue;\n            uint256 reward = stakerInfo[staker].initialReward;\n\n            printToken(PrintedToken);\n            VXInterface.Stake(false, staker, reward);\n\n            stakerInfo[staker].accumulativeReward += stakerInfo[staker].initialReward;\n            stakerInfo[staker].rewardTime = 10 seconds + block.timestamp + EPOCH_DURATION;\n            sharedRewards += reward;\n            accumulativePrintedToken += PrintedToken;\n            stakerInfo[staker].totalPrintedToken += PrintedToken;\n        }\n    }\n\n    function calculateNextTimeReward(uint256 _startTime) internal pure returns (uint256) {\n        uint256 NextTime = _startTime + EPOCH_DURATION;\n        return NextTime;\n\n    }\n\n    function printToken(uint256 _rewardValue) internal onlyAuthorized{\n        require(_rewardValue > 0, \"No reward to claim\");\n        VXInterface.printVXT(address(this), _rewardValue);\n\n        emit TokenPrinted(address(this), _rewardValue);\n    }\n\n    function filterStakers() private view returns (address[] memory) {\n        uint256 currentTime = block.timestamp;\n        uint256 stakerCount = Stakeraddress.length;\n        uint256 rewardsCount = 0;\n\n        for (uint256 i = 0; i < stakerCount; ++i) {\n            address staker = Stakeraddress[i];\n            if (currentTime >= stakerInfo[staker].rewardTime) {\n                ++rewardsCount;\n            }\n        }\n\n        address[] memory stakersToReward = new address[](rewardsCount);\n\n        uint256 index = 0;\n        for (uint256 i = 0; i < stakerCount; ++i) {\n            address staker = Stakeraddress[i];\n            if (currentTime >= stakerInfo[staker].rewardTime) {\n                stakersToReward[index] = staker;\n                ++index;\n            }\n        }\n\n        return stakersToReward;\n    }\n\n    function calculateRewardValue(uint256 stakeValue) private pure returns (uint256) {\n\n        return calculatePrintValue(stakeValue).mul(STAKE_REWARD_PERCENTAGE).div(100);\n    }\n\n    function calculatePrintValue(uint256 stakeValue) private pure returns (uint256) {\n\n        return stakeValue.mul(15).div(100);\n    }\n\n    function getStakerRewardTimes() public view returns (address[] memory stakerAddressList, uint256[] memory rewardTimeList) {\n        uint256 stakerCount = Stakeraddress.length;\n        stakerAddressList = new address[](stakerCount);\n        rewardTimeList = new uint256[](stakerCount);\n\n        for (uint256 i = 0; i < stakerCount; i++) {\n            address staker = Stakeraddress[i];\n            stakerAddressList[i] = staker;\n            rewardTimeList[i] = stakerInfo[staker].rewardTime;\n        }\n\n        return (stakerAddressList, rewardTimeList);\n    }\n\n\n}\n"
    },
    "contracts/VotreXToken.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\n\ncontract VotreXTokenT2 is ERC20, ERC20Burnable, ERC20Pausable, ERC20Permit {\n\tconstructor(\n\t\tuint256 _initialMintedToken,\n\t\tuint256 _MaxSupplies\n\t)\n\tERC20(\"VotreXTokenT2\", \"VOXT2\") ERC20Permit(\"VotreXToken\") {\n\t\tOwner = msg.sender;\n\t\tMAXSupply = _MaxSupplies * 10 ** decimals();\n\t\t_mint(address(this), _initialMintedToken * 10 ** decimals());\n\t\tactiveSystem = true;\n\t\tcurrentMintAmount =\n\t\t\t(_MaxSupplies - _initialMintedToken) *\n\t\t\t10 ** decimals();\n\t}\n\n\taddress private Owner;\n\tbool private activeSystem;\n\tuint256 public immutable MAXSupply;\n\tuint256 private currentMintAmount;\n\n\tmapping(address Owner => IContract) public ContractStorage;\n\n\tstruct IContract {\n\t\taddress Authorized;\n\t\taddress stakingContract;\n\t\taddress dexContract;\n\t\taddress VotreXContract;\n\t\taddress interfaceContract;\n\t}\n\n\tmodifier onlyInterface() {\n\t\trequire(\n\t\t\tmsg.sender == ContractStorage[Owner].interfaceContract,\n\t\t\t\"Caller is not an interface\"\n\t\t);\n\t\t_;\n\t}\n\n\tmodifier onlyExecutor() {\n\t\trequire(msg.sender == ContractStorage[Owner].Authorized);\n\t\t_;\n\t}\n\n\tmodifier onlyAuthorized() {\n\t\trequire(\n\t\t\tmsg.sender == ContractStorage[Owner].interfaceContract ||\n\t\t\t\tmsg.sender == Owner,\n\t\t\t\"Token - Caller is not an Authorized\"\n\t\t);\n\t\t_;\n\t}\n\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == Owner, \"Token - Caller is not an Authorized\");\n\t\t_;\n\t}\n\n\tmodifier onlyPaused() {\n\t\trequire(activeSystem == false, \"System still active\");\n\t\t_;\n\t}\n\n\tfunction customApprove(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 amount\n\t) external onlyInterface {\n\t\t_approve(owner, spender, amount);\n\t}\n\n\tfunction pause() public onlyOwner {\n\t\trequire(activeSystem == true, \"System is Paused\");\n\t\t_pause();\n\t\tactiveSystem = false;\n\t}\n\n\tfunction Activate() public onlyOwner {\n\t\trequire(activeSystem == false, \"System is Activated\");\n\t\t_unpause();\n\t\tactiveSystem = true;\n\t}\n\n\tfunction setAutomationExecutor(\n\t\taddress _executorAddress\n\t) external onlyOwner onlyPaused {\n\t\trequire(_executorAddress != address(0), \"Invalid contract address\");\n\t\trequire(\n\t\t\t_executorAddress != ContractStorage[msg.sender].Authorized,\n\t\t\t\"Already Registered Executor\"\n\t\t);\n\t\tContractStorage[msg.sender].Authorized = _executorAddress;\n\t}\n\n\tfunction setStakingContract(\n\t\taddress _stakingContractAddress\n\t) external onlyOwner onlyPaused {\n\t\trequire(\n\t\t\t_stakingContractAddress != address(0),\n\t\t\t\"Invalid contract address\"\n\t\t);\n\t\trequire(\n\t\t\t_stakingContractAddress !=\n\t\t\t\tContractStorage[msg.sender].stakingContract,\n\t\t\t\"Already Registered Staking\"\n\t\t);\n\t\tContractStorage[msg.sender].stakingContract = _stakingContractAddress;\n\t}\n\n\tfunction setDexContract(\n\t\taddress _DEXContractAddress\n\t) external onlyOwner onlyPaused {\n\t\trequire(_DEXContractAddress != address(0), \"Invalid contract address\");\n\t\trequire(\n\t\t\t_DEXContractAddress != ContractStorage[msg.sender].dexContract,\n\t\t\t\"Already Registered DEX\"\n\t\t);\n\t\tContractStorage[msg.sender].dexContract = _DEXContractAddress;\n\t}\n\n\tfunction setInterface(\n\t\taddress _InterfaceContractAddress\n\t) external onlyOwner onlyPaused {\n\t\trequire(\n\t\t\t_InterfaceContractAddress != address(0),\n\t\t\t\"Invalid contract address\"\n\t\t);\n\t\trequire(\n\t\t\t_InterfaceContractAddress !=\n\t\t\t\tContractStorage[msg.sender].interfaceContract,\n\t\t\t\"Already Registered Interface\"\n\t\t);\n\t\tContractStorage[msg.sender]\n\t\t\t.interfaceContract = _InterfaceContractAddress;\n\t}\n\n\tfunction setVotreXContract(\n\t\taddress _VotreXContractAddress\n\t) external onlyOwner onlyPaused {\n\t\trequire(\n\t\t\t_VotreXContractAddress != address(0),\n\t\t\t\"Invalid contract address\"\n\t\t);\n\t\trequire(\n\t\t\t_VotreXContractAddress !=\n\t\t\t\tContractStorage[msg.sender].VotreXContract,\n\t\t\t\"Already Registered VotreX\"\n\t\t);\n\t\tContractStorage[msg.sender].VotreXContract = _VotreXContractAddress;\n\t}\n\n\tfunction checkBlockTime() public view returns (uint256) {\n\t\treturn block.timestamp;\n\t}\n\n\tfunction calculateHalving() public view returns (uint256) {\n\t\tuint256 nextMint = currentMintAmount / 2;\n\n\t\treturn nextMint;\n\t}\n\n\tfunction autoMinting() public onlyExecutor {\n\t\trequire(totalSupply() < MAXSupply, \"Max Supply Reached\");\n\n\t\tif (currentMintAmount == 0) {\n\t\t\tuint256 finalMintingValue = MAXSupply - totalSupply();\n\t\t\t_mint(address(this), finalMintingValue);\n\t\t} else {\n\t\t\tuint256 mintingValue = calculateHalving();\n\t\t\t_mint(address(this), mintingValue);\n\t\t\tcurrentMintAmount = mintingValue;\n\t\t}\n\t}\n\n\tfunction mint(address to, uint256 amount) public onlyAuthorized {\n\t\tif (msg.sender == ContractStorage[Owner].interfaceContract) {\n\t\t\trequire(totalSupply() < MAXSupply);\n\t\t\t_mint(to, amount);\n\t\t} else if (msg.sender == Owner) {\n\t\t\tuint256 mintingValue = amount * 10 ** decimals();\n\t\t\trequire(totalSupply() < MAXSupply);\n\t\t\trequire(amount < 4000000);\n\t\t\t_mint(to, mintingValue);\n\t\t\tcurrentMintAmount = currentMintAmount / 2;\n\t\t}\n\t}\n\n\tfunction burn(uint256 value) public override onlyOwner {\n\t\tuint256 burnedValue = value * 10 ** decimals();\n\t\t_burn(address(this), burnedValue);\n\t}\n\n\tfunction getCurrentMintAmount() external view returns (uint256) {\n\t\treturn currentMintAmount;\n\t}\n\n\tfunction getOwnerAddress() external view onlyOwner returns (address) {\n\t\treturn (Owner);\n\t}\n\n\tfunction _update(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value\n\t) internal override(ERC20, ERC20Pausable) {\n\t\tsuper._update(from, to, value);\n\t}\n}\n"
    },
    "contracts/VotreXTxInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"./VotreXToken.sol\";\n\ncontract VotreXTXInterface {\n\n    constructor(address _tokenAddress) {\n        InterfaceMaster = msg.sender;\n        interfaceActivated = false;\n        vxtToken = VotreXTokenT2(_tokenAddress);\n        ContractStorage[msg.sender].tokenContract = _tokenAddress;\n    }\n\n    // gas: 646200;\n\n    VotreXTokenT2 internal immutable vxtToken;\n    bool private interfaceActivated;\n    address private VotreXContract;\n    address private dexContract;\n    address private airdropContract;\n    address private stakingContract;\n    address private immutable InterfaceMaster;\n    uint256 internal immutable MaxAllowances = 15000000 * 10 ** 18;\n\n    mapping(address InterfaceMaster => IContract) public ContractStorage;\n    // mapping(address => uint256) public allowances;\n\n    struct IContract{\n        address Authorized;\n        address tokenContract;\n        address stakingContract;\n        address dexContract;\n        address VotreXContract;\n        address airdropContract;\n    }\n\n    modifier onlyActivated() {\n        require(interfaceActivated == true, \"Interface not Active\");\n        _;\n    }\n\n    modifier onlyPaused() {\n        require(interfaceActivated == false, \"Interface still Active\");\n        _;\n    }\n\n    modifier onlyStaking() {\n        require(\n            msg.sender == stakingContract,\n            \"Interface - Caller is not a Stake Contract\"\n        );\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == InterfaceMaster, \"Interface - Caller is not Owner!\");\n        _;\n    }\n\n    modifier onlyDeX() {\n        require(msg.sender == dexContract, \"Interface - Caller is not DexApps!\");\n        _;\n    }\n\n    modifier onlyAuthorized() {\n        require(\n            msg.sender == InterfaceMaster ||\n            msg.sender == dexContract ||\n            msg.sender == stakingContract ||\n            msg.sender == VotreXContract ||\n            msg.sender == airdropContract,\n            \"Interface - Caller is not an Authorized!\"\n        );\n        _;\n    }\n\n    event BuyVXTEvent(address Buyer, uint256 VXTTransfered);\n    event TransferedVXTEvent(address Receiver, uint256 VXTTransfered);\n    event withdrawnToken(address from, address Receiver, uint256 VXTTransfered);\n    event VotedEvent(address Voter, uint256 VotedPower);\n    event TokenDropped(address Recipient, uint256 DroppedValue);\n\n    function changeSystemState() external onlyOwner{\n\n        if (interfaceActivated == false) {\n            interfaceActivated = true;\n        } else if (interfaceActivated == true) {\n            interfaceActivated = false;\n        }\n\n    }\n\n    function isActivatedInterfaceCheck() public view returns (bool isActivatedInterface) {\n\n        return interfaceActivated;\n    }\n\n    function getTokenContract() external view onlyOwner returns(address){\n        return ContractStorage[msg.sender].tokenContract;\n    }\n\n    function setVotreXSys (address _VotreXContract) external onlyOwner onlyPaused{\n        require(\n            _VotreXContract != ContractStorage[msg.sender].VotreXContract,\n            \"Interface - Registered VotreX\"\n        );\n\n        require(\n            _VotreXContract != address(0),\n            \"Interface - Invalid contract address\"\n        );\n\n        VotreXContract = _VotreXContract;\n        ContractStorage[msg.sender].VotreXContract = _VotreXContract;\n    }\n\n    function setStakingContract (address _stakingAddress) external onlyOwner onlyPaused{\n        require(\n            _stakingAddress != ContractStorage[msg.sender].stakingContract,\n            \"Interface - Registered VotreX Staking\"\n        );\n\n        require(\n            _stakingAddress != address(0),\n            \"Interface - Invalid contract address\"\n        );\n\n        stakingContract = _stakingAddress;\n        ContractStorage[msg.sender].stakingContract = _stakingAddress;\n    }\n\n    function setDeX (address _dexContract) external onlyOwner onlyPaused{\n        require(\n            _dexContract != ContractStorage[msg.sender].dexContract,\n            \"Interface - Registered VotreX DeX\"\n        );\n\n        require(\n            _dexContract != address(0),\n            \"Invalid contract address\"\n        );\n\n        dexContract = _dexContract;\n        ContractStorage[msg.sender].dexContract = _dexContract;\n    }\n\n    function setAirdrop (address _AirdropContract) external onlyOwner onlyPaused{\n        require(\n            _AirdropContract != ContractStorage[msg.sender].airdropContract,\n            \"Interface - Registered VotreX Airdrop\"\n        );\n\n        require(\n            _AirdropContract != address(0),\n            \"Invalid contract address\"\n        );\n\n        airdropContract = _AirdropContract;\n        ContractStorage[msg.sender].airdropContract = _AirdropContract;\n    }\n\n    function approveTxInterface(uint32 amount) external onlyOwner {\n        uint256 TokenConversion = uint256(amount) * 10 ** vxtToken.decimals();\n\n        require(address(this) != address(0), \"Interface - Invalid address\");\n        require(TokenConversion < MaxAllowances, \"Can not approve more than limit\");\n\n        vxtToken.customApprove(address(vxtToken), address(this), TokenConversion);\n    }\n\n    function approveVotreX(uint256 amount) external onlyAuthorized onlyActivated{\n        uint256 TokenConversion = amount * 10 ** vxtToken.decimals();\n\n        require(ContractStorage[msg.sender].VotreXContract != address(0), \"Interface - VotreX Address not set\");\n        require(TokenConversion < MaxAllowances, \"Can not approve more than limit\");\n\n        vxtToken.customApprove(VotreXContract, address(this), TokenConversion);\n    }\n\n    function approveAirdrop(uint256 amount) external onlyAuthorized onlyActivated{\n        uint256 TokenConversion = amount * 10 ** vxtToken.decimals();\n\n        require(address(this) != address(0), \"Interface - Invalid address\");\n        require(TokenConversion < MaxAllowances, \"Can not approve more than limit\");\n\n        vxtToken.customApprove(msg.sender, address(this), TokenConversion);\n    }\n\n    function approveStaking(uint256 amount) external onlyAuthorized onlyActivated{\n        uint256 TokenConversion = amount * 10 ** vxtToken.decimals();\n\n        require(msg.sender != address(0), \"Interface - Staking Address not set\");\n        require(amount < MaxAllowances, \"Interface - Can not approve more than limit\");\n\n        vxtToken.customApprove(msg.sender, address(this), TokenConversion);\n    }\n\n    function approveDeX(uint256 amount) external virtual onlyAuthorized onlyActivated{\n        uint256 TokenConversion = amount * 10 ** vxtToken.decimals();\n\n        require(msg.sender != address(0), \"Interface - DeX Address not set\");\n        require(TokenConversion < MaxAllowances, \"Interface - Can not approve more than limit\");\n\n        vxtToken.customApprove(msg.sender, address(this), TokenConversion);\n    }\n\n    function checkApprovalLimit(address _ContractAddress) external view returns (uint256){\n        if(_ContractAddress == ContractStorage[msg.sender].VotreXContract){\n            return (\n                vxtToken.allowance(\n                    ContractStorage[msg.sender].VotreXContract, address(this)\n                )\n            );\n        }\n        else if(_ContractAddress == ContractStorage[msg.sender].dexContract){\n            return (\n                vxtToken.allowance(\n                    ContractStorage[msg.sender].dexContract, address(this)\n                )\n            );\n        }\n        else if(_ContractAddress == ContractStorage[msg.sender].stakingContract){\n            return (\n                vxtToken.allowance(\n                    ContractStorage[msg.sender].stakingContract, address(this)\n                )\n            );\n        }\n        else if(_ContractAddress == ContractStorage[msg.sender].airdropContract){\n            return (\n                vxtToken.allowance(\n                    ContractStorage[msg.sender].airdropContract, address(this)\n                )\n            );\n        }\n        else {\n            return (404);\n        }\n    }\n\n    function checkBalance(address account) external view virtual onlyActivated returns (uint256) {\n        return vxtToken.balanceOf(account);\n    }\n\n    function balanceTx(address _Recipient, uint256 _value) external onlyOwner{\n        uint256 vxtNominalTransfer = _value * 10 ** vxtToken.decimals();\n\n        if (\n            _Recipient == ContractStorage[msg.sender].VotreXContract\n        ) {\n            if (\n                vxtToken.allowance(msg.sender, address(this)) >= MaxAllowances\n                &&\n                vxtToken.allowance(msg.sender, address(this)) >= vxtNominalTransfer\n            )\n            {\n                vxtToken.transferFrom(address(vxtToken), VotreXContract, vxtNominalTransfer);\n            } else {\n                vxtToken.customApprove(msg.sender, _Recipient, vxtNominalTransfer);\n                vxtToken.customApprove(msg.sender, address(this), vxtNominalTransfer);\n\n                vxtToken.transferFrom(address(vxtToken), VotreXContract, vxtNominalTransfer);\n            }\n        } else if (\n            _Recipient == ContractStorage[msg.sender].dexContract\n        ) {\n            if (\n                vxtToken.allowance(msg.sender, address(this)) >= MaxAllowances\n                &&\n                vxtToken.allowance(msg.sender, address(this)) >= vxtNominalTransfer\n            )\n            {\n                vxtToken.transferFrom(address(vxtToken),dexContract, vxtNominalTransfer);\n            }\n            else {\n                vxtToken.customApprove(msg.sender, _Recipient, vxtNominalTransfer);\n                vxtToken.customApprove(msg.sender, address(this), vxtNominalTransfer);\n\n                vxtToken.transferFrom(address(vxtToken), dexContract, vxtNominalTransfer);\n            }\n        } else if (_Recipient == InterfaceMaster) {\n            require(_value < 4000000, \"Interface - Transfer limit Reached\");\n            require(msg.sender == InterfaceMaster, \"Interface - Not Authorized\");\n\n            // Case for Interface Master\n            if (\n                vxtToken.allowance(msg.sender, address(this)) >= vxtNominalTransfer\n                &&\n                vxtToken.allowance(msg.sender, address(this)) >= MaxAllowances\n            ){\n                vxtToken.transferFrom(address(vxtToken), address(InterfaceMaster), vxtNominalTransfer);\n            } else {\n                vxtToken.customApprove(address(vxtToken), address(this), vxtNominalTransfer);\n                vxtToken.customApprove(address(vxtToken), InterfaceMaster, vxtNominalTransfer);\n\n                vxtToken.transferFrom(address(vxtToken), msg.sender, vxtNominalTransfer);\n\n                emit TransferedVXTEvent(msg.sender, vxtNominalTransfer);\n            }\n        }else if (\n            _Recipient != InterfaceMaster||\n            _Recipient != ContractStorage[msg.sender].dexContract ||\n            _Recipient != ContractStorage[msg.sender].VotreXContract\n        ){\n            revert();\n        }\n    }\n\n    function TokenWithdraw(uint256 _value)external onlyOwner{\n        uint256 vxtNominalTransfer = _value * 10 ** vxtToken.decimals();\n        if (\n                vxtToken.allowance(VotreXContract, address(this)) >= MaxAllowances\n                &&\n                vxtToken.allowance(VotreXContract, address(this)) >= vxtNominalTransfer\n            )\n            {\n                vxtToken.transferFrom(VotreXContract, msg.sender, vxtNominalTransfer);\n            } else {\n                vxtToken.customApprove(VotreXContract, address(this), vxtNominalTransfer);\n\n                vxtToken.transferFrom(VotreXContract,msg.sender, vxtNominalTransfer);\n        }\n    }\n\n    function VotreXTx(\n        address _Recipient,\n        uint256 _value\n    )\n        external\n        onlyAuthorized\n        onlyActivated\n    {\n        uint256 vxtNominalTransfer = _value * 10 ** vxtToken.decimals();\n\n        if (msg.sender == VotreXContract) {\n            // Case for VotreX\n            if (\n                vxtToken.allowance(VotreXContract, address(this)) >= vxtNominalTransfer\n                &&\n                vxtToken.allowance(VotreXContract, address(this)) >= MaxAllowances\n            )\n            {\n                vxtToken.transferFrom(VotreXContract, _Recipient, vxtNominalTransfer);\n            } else if (\n                vxtToken.allowance(VotreXContract, address(this)) <= vxtNominalTransfer\n                &&\n                vxtToken.allowance(VotreXContract, address(this)) <= MaxAllowances\n            ){\n                vxtToken.customApprove(VotreXContract, _Recipient, vxtNominalTransfer);\n                vxtToken.customApprove(VotreXContract, address(this), vxtNominalTransfer);\n                vxtToken.customApprove(_Recipient, address(this), vxtNominalTransfer);\n\n                vxtToken.transferFrom(VotreXContract, _Recipient, vxtNominalTransfer);\n\n                emit TransferedVXTEvent(VotreXContract, vxtNominalTransfer);\n            }\n        } else if (msg.sender == dexContract) {\n            // Case for DeX\n            if (\n                vxtToken.allowance(address(dexContract), address(this)) >= _value\n                &&\n                vxtToken.allowance(address(dexContract), address(this)) >= MaxAllowances\n            )\n            {\n                vxtToken.transferFrom(address(dexContract), _Recipient, _value);\n            }\n            else {\n                vxtToken.customApprove(address(dexContract), _Recipient, _value);\n                vxtToken.customApprove(address(dexContract), address(this), _value);\n\n                vxtToken.transferFrom(address(dexContract), _Recipient, _value);\n\n                emit BuyVXTEvent(address(dexContract), _value);\n            }\n        } else if (msg.sender == stakingContract) {\n            // Case for Staking Contract\n            if (\n                vxtToken.allowance(msg.sender, address(this)) >= _value\n                &&\n                vxtToken.allowance(msg.sender, address(this)) >= MaxAllowances\n            ){\n                vxtToken.transferFrom(msg.sender, _Recipient, _value); \n            }\n            else {\n                vxtToken.customApprove(msg.sender, _Recipient, _value);\n                vxtToken.customApprove(msg.sender, address(this), _value);\n                vxtToken.customApprove(_Recipient, address(this), _value);\n\n                vxtToken.transferFrom(msg.sender, _Recipient, _value);\n\n                emit withdrawnToken(msg.sender, _Recipient, _value);\n            }\n        } else if (msg.sender == airdropContract) {\n            // Case for Airdrop\n            if (\n                vxtToken.allowance(msg.sender, address(this)) >= _value\n            ){\n                vxtToken.transferFrom(msg.sender, _Recipient, _value);\n            }\n            else {\n                vxtToken.customApprove(msg.sender, _Recipient, _value);\n                vxtToken.customApprove(msg.sender, address(this), _value);\n\n                vxtToken.transferFrom(msg.sender, _Recipient, _value);\n\n                emit TokenDropped(_Recipient, _value);\n            }\n        }\n    }\n\n    function VoteTx(address _Sender, uint256 _value) external onlyAuthorized onlyActivated{\n        require (msg.sender == VotreXContract, \"Interface - Not VotreX\");\n\n        uint256 vxtNominalTransfer = _value * 10 ** vxtToken.decimals();\n\n        if (\n            vxtToken.allowance(msg.sender, address(this)) >= vxtNominalTransfer\n            &&\n            vxtToken.allowance(msg.sender, address(this)) >= MaxAllowances\n        ) {\n            vxtToken.transferFrom(_Sender, msg.sender, vxtNominalTransfer);\n        } else {\n            vxtToken.customApprove(_Sender, address(this), vxtNominalTransfer);\n\n            vxtToken.transferFrom(_Sender, msg.sender, vxtNominalTransfer);\n\n            emit VotedEvent(msg.sender, vxtNominalTransfer);\n        }\n    }\n\n    function printVXT(address _recipient, uint256 _rewardValue) external onlyAuthorized onlyActivated{\n        vxtToken.mint(_recipient, _rewardValue);\n    }\n\n    function totalSupplies() external view returns(uint256) {\n        return vxtToken.totalSupply();\n    }\n\n    function Stake(\n        bool isStaking,\n        address _Recipient,\n        uint256 _value\n    )\n        external\n        onlyAuthorized\n        onlyActivated\n    {\n        if (\n            msg.sender == stakingContract\n            &&\n            isStaking == true\n        ) {\n            // Case for Staking\n            if (\n                vxtToken.allowance(msg.sender, address(this)) >= _value\n                &&\n                vxtToken.allowance(msg.sender, _Recipient) >= _value\n                &&\n                vxtToken.allowance(msg.sender, address(this)) >= MaxAllowances\n                &&\n                vxtToken.allowance(msg.sender, _Recipient) >= MaxAllowances\n                )\n            {\n                vxtToken.transferFrom(_Recipient, msg.sender, _value);\n            } else {\n                // Case 4: Approve and transfer\n                vxtToken.customApprove(_Recipient, address(this), _value);\n                vxtToken.customApprove(msg.sender, address(this), _value);\n                vxtToken.customApprove(_Recipient, msg.sender, _value);\n\n                vxtToken.transferFrom(_Recipient, msg.sender, _value);\n            }\n        } else if (\n            msg.sender == stakingContract\n            &&\n            isStaking == false\n        ) {\n            // Case for unStaking & Reward Distribution\n            if (\n                vxtToken.allowance(msg.sender, address(this)) >= _value\n                &&\n                vxtToken.allowance(msg.sender, _Recipient) >= _value\n                &&\n                vxtToken.allowance(msg.sender, address(this)) >= MaxAllowances\n                &&\n                vxtToken.allowance(msg.sender, _Recipient) >= MaxAllowances\n            )\n            {\n                vxtToken.transferFrom(msg.sender, _Recipient, _value);\n            }\n            else {\n                vxtToken.customApprove(msg.sender, _Recipient, _value);\n\n                vxtToken.transferFrom(msg.sender, _Recipient, _value);\n            }\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}