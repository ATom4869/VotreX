{
  "language": "Solidity",
  "sources": {
    "contracts/Election.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// pragma abicoder v2;\r\npragma solidity ^0.8.24;\r\n\r\nimport \"./UtilityLibrary.sol\";\r\n\r\ncontract TestingElection {\r\n\r\n    constructor() {\r\n        // Create a test election ID\r\n        string memory testElectionID = \"GKPS-Bp1\";\r\n        bytes32 packedElectionID = bytes32(abi.encodePacked(testElectionID));\r\n        \r\n        // Initialize test election\r\n        ElectionDetail storage testElection = electionInfo[packedElectionID];\r\n        testElection.electionID = packedElectionID;\r\n        testElection.electionName = bytes32(\"Seksi Bapa\");\r\n        testElection.status = ElectionStatus.Started;\r\n        testElection.waveNumber = 1;\r\n        testElection.totalParticipants = 10; // Example total participants\r\n        \r\n        // Initialize candidates\r\n        testElection.candidates.push(\r\n            CandidateDetail({\r\n                candidateID: 0,\r\n                candidateName: \"Mavuika\",\r\n                candidateVoteCount: 1\r\n            })\r\n        );\r\n        \r\n        testElection.candidates.push(\r\n            CandidateDetail({\r\n                candidateID: 1,\r\n                candidateName: \"Morax\",\r\n                candidateVoteCount: 6\r\n            })\r\n        );\r\n        \r\n        testElection.candidates.push(\r\n            CandidateDetail({\r\n                candidateID: 2,\r\n                candidateName: \"Neuvillette\",\r\n                candidateVoteCount: 1\r\n            })\r\n        );\r\n        \r\n        testElection.candidates.push(\r\n            CandidateDetail({\r\n                candidateID: 3,\r\n                candidateName: \"Nahida\",\r\n                candidateVoteCount: 2\r\n            })\r\n        );\r\n    }\r\n\tmapping(string => Organization) public organizationData;\r\n\tmapping(address => ElectionAdmins) public admin;\r\n\tmapping(address => Voter) public voters;\r\n\tmapping(bytes32 => address[]) private votersList;\r\n\tmapping(bytes32 => mapping(address => bool)) public hasVoted;\r\n\tmapping(bytes32 => mapping(string => CandidateDetail))\r\n\t\tpublic temporalCandidates;\r\n\tmapping(bytes32 => ElectionDetail) public electionInfo;\r\n\tmapping(string => ElectionResult) public electionResults;\r\n\tmapping(bytes32 => bool) private electionExistanceChecks;\r\n\tmapping(bytes16 => bool) private votersIDExists;\r\n\tmapping(address => bool) private registeredAdmin;\r\n\r\n\tenum ElectionStatus {\r\n\t\tPreparation,\r\n\t\tStarted,\r\n\t\tHeadToHeadWave,\r\n\t\tFinished,\r\n\t\tFailed\r\n\t}\r\n\r\n\tenum OrganizationType {\r\n\t\tOrganization,\r\n\t\tChurches,\r\n\t\tCorporate\r\n\t}\r\n\r\n\tstruct Organization {\r\n\t\tOrganizationType orgType;\r\n\t\taddress electionAdminAddresses;\r\n\t\tuint256 onPreparationElectionCounter;\r\n\t\tuint256 activeElectionCounter;\r\n\t\tuint256 archivedElectionCounter;\r\n\t\tuint256 totalMembers;\r\n\t\tbytes32 orgName;\r\n\t\tstring orgID;\r\n\t\tbytes32[] electionIDs;\r\n\t\tbytes32[] ElectionName;\r\n\t\tElectionStatus[] electionStatus;\r\n\t}\r\n\r\n\tstruct ElectionAdmins {\r\n\t\tbool isRegistered;\r\n\t\tuint8 adminOrgCount;\r\n\t\tbytes10 AdminVoterIDOrg1;\r\n\t\tbytes10 AdminVoterIDOrg2;\r\n\t\taddress electionAdminAddress;\r\n\t\tuint256 nextOrgCreationBlock;\r\n\t\tbytes32 adminName;\r\n\t\tstring RegisteredOrgID1;\r\n\t\tstring RegisteredOrgID2;\r\n\t}\r\n\r\n\tstruct ElectionResult {\r\n\t\tbool isPruned;\r\n\t\taddress adminAddress;\r\n\t\tuint256 waveNumber;\r\n\t\tuint startTime;\r\n\t\tuint endTime;\r\n\t\tuint totalVoter;\r\n\t\tbytes32 electionID;\r\n\t\tbytes32 electionName;\r\n\t\tbytes32 digitalSignature;\r\n\t\tstring registeredOrganization;\r\n\t\tstring electionWinner;\r\n\t\tstring signedBy;\r\n\t\tCandidateDetail[] candidates;\r\n\t}\r\n\r\n\tstruct Voter {\r\n\t\tbool isRegistered;\r\n\t\taddress VoterAddress;\r\n\t\tbytes16 VoterIDOrg1;\r\n\t\tbytes16 VoterIDOrg2;\r\n\t\tstring VoterName;\r\n\t\tstring RegisteredOrgID1;\r\n\t\tstring RegisteredOrgID2;\r\n\t}\r\n\r\n\tstruct ElectionDetail {\r\n\t\tElectionStatus status;\r\n\t\tuint8 candidateList;\r\n\t\tbool isFinished;\r\n\t\tbool isHaveCandidateMode;\r\n\t\tbytes32 electionID;\r\n\t\tbytes32 electionName;\r\n\t\tuint startTime;\r\n\t\tuint endTime;\r\n\t\tstring orgID;\r\n\t\tuint256 totalParticipants;\r\n\t\tuint256 waveNumber;\r\n\t\tCandidateDetail[] candidates;\r\n\t\tbool isTiedVoting;\r\n\t}\r\n\r\n    struct CandidateDetail {\r\n\t\tuint8 candidateID;\r\n\t\tuint256 candidateVoteCount;\r\n\t\tstring candidateName;\r\n\t}\r\n\r\n    function finishElection(\r\n\t\tstring memory _userElectionID,\r\n\t\tbytes32 _dataHash,\r\n\t\tuint256 _threshold\r\n\t) external {\r\n\t\tbytes32 packedElectionID = bytes32(abi.encodePacked(_userElectionID));\r\n\t\tstring memory orgIDs = UtilityLibrary.extractOrgId(_userElectionID);\r\n\t\tbytes32 electionIdBytes = keccak256(abi.encodePacked(_userElectionID));\r\n\r\n\t\t// Cache storage in memory to reduce storage reads\r\n\t\tElectionDetail storage elections = electionInfo[packedElectionID];\r\n\r\n\t\t// Validation checks\r\n\t\trequire(\r\n\t\t\telections.status == ElectionStatus.Started,\r\n\t\t\t\"Election is not active\"\r\n\t\t);\r\n\t\trequire(!elections.isFinished, \"Election finished\");\r\n\t\trequire(bytes(_userElectionID).length > 0, \"Invalid election ID\");\r\n\t\trequire(_dataHash.length > 0, \"Invalid data hash\");\r\n\r\n\t\tuint256 candidatesLength = elections.candidates.length;\r\n\t\trequire(candidatesLength >= 2, \"Not enough candidates\");\r\n\r\n\t\t// Calculate quorum threshold once\r\n\t\tuint256 quorumThreshold = calculateValidElection(_userElectionID);\r\n\r\n\t\t// Memory array to avoid repeated storage reads\r\n\t\tCandidateDetail[] memory candidatesMem = new CandidateDetail[](\r\n\t\t\tcandidatesLength\r\n\t\t);\r\n\t\tfor (uint256 i = 0; i < candidatesLength; i++) {\r\n\t\t\tcandidatesMem[i] = elections.candidates[i];\r\n\t\t}\r\n\r\n\t\t// Check for immediate quorum - scan once to find winning candidate\r\n\t\tbool quorumReached = false;\r\n\t\tuint256 winningCandidateIndex;\r\n\t\tbool kisquosientMode = false;\r\n\t\tuint256 passedCandidateCount = 0;\r\n\r\n\t\t// Combined loop to check all conditions at once\r\n\t\tfor (uint256 i = 0; i < candidatesLength; ++i) {\r\n\t\t\tuint256 voteCount = candidatesMem[i].candidateVoteCount;\r\n\r\n\t\t\tif (voteCount > quorumThreshold) {\r\n\t\t\t\tquorumReached = true;\r\n\t\t\t\twinningCandidateIndex = i;\r\n\t\t\t\tbreak;\r\n\t\t\t} else {\r\n\t\t\t\tif (voteCount > _threshold) {\r\n\t\t\t\tkisquosientMode = true;\r\n\t\t\t\t++passedCandidateCount;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (quorumReached) {\r\n\t\t\t// Quorum reached - handle winning case\r\n\t\t\t_finalizeElection(\r\n\t\t\t\t_userElectionID,\r\n\t\t\t\tpackedElectionID,\r\n\t\t\t\torgIDs,\r\n\t\t\t\t_dataHash,\r\n\t\t\t\twinningCandidateIndex\r\n\t\t\t);\r\n\t\t\treturn;\r\n\t\t} else if (!quorumReached && kisquosientMode == true) {\r\n\t\t\t// Handle threshold-passing candidates\r\n\t\t\t_handleThresholdCandidates(\r\n\t\t\t\t_userElectionID,\r\n\t\t\t\telectionIdBytes,\r\n\t\t\t\tpassedCandidateCount,\r\n\t\t\t\t_threshold,\r\n\t\t\t\tpackedElectionID\r\n\t\t\t);\r\n\t\t\treturn;\r\n\t\t}\r\n        revert(\"No candidates passed threshold\");\r\n\t}\r\n\t\r\n\tfunction calculateAge(bytes32 encryptedDate, int256 timeOffset) internal view returns (int256) {\r\n        // Convert bytes32 to uint256 first, then to int256\r\n        int256 birthTimeStamp = int256(uint256(encryptedDate)) - timeOffset;\r\n        int256 currentTime = int256(block.timestamp);\r\n        \r\n        // Calculate age in seconds and convert to years\r\n        int256 ageInSeconds = currentTime - birthTimeStamp;\r\n        int256 ageInYears = ageInSeconds / 31536000; // seconds in a year\r\n        \r\n        return ageInYears;\r\n    }\r\n\r\n    function extractOrgId(string memory _userElectionID) internal pure returns (string memory) {\r\n        string[] memory parts = UtilityLibrary.splitString(_userElectionID, \"-\");\r\n        require(parts.length > 0, \"Invalid custom election ID format\");\r\n\r\n        return parts[0];\r\n    }\r\n\r\n\t// Internal function to finalize an election\r\n\tfunction _finalizeElection(\r\n\t\tstring memory _userElectionID,\r\n\t\tbytes32 packedElectionID,\r\n\t\tstring memory orgIDs,\r\n\t\tbytes32 _dataHash,\r\n\t\tuint256 winningCandidateIndex\r\n\t) internal {\r\n\t\tElectionDetail storage elections = electionInfo[packedElectionID];\r\n\r\n\t\t// Cache winner name\r\n\t\tstring memory electionWinner = elections\r\n\t\t\t.candidates[winningCandidateIndex]\r\n\t\t\t.candidateName;\r\n\t\tstring memory adminName = getAdminName(msg.sender);\r\n\r\n\t\t// Create result record\r\n\t\tElectionResult storage newElectionResult = electionResults[\r\n\t\t\t_userElectionID\r\n\t\t];\r\n\t\tnewElectionResult.isPruned = true;\r\n\t\tnewElectionResult.totalVoter = elections.totalParticipants;\r\n\t\tnewElectionResult.adminAddress = msg.sender;\r\n\t\tnewElectionResult.startTime = elections.startTime;\r\n\t\tnewElectionResult.endTime = elections.endTime;\r\n\t\tnewElectionResult.digitalSignature = _dataHash;\r\n\t\tnewElectionResult.registeredOrganization = elections.orgID;\r\n\t\tnewElectionResult.electionID = packedElectionID;\r\n\t\tnewElectionResult.waveNumber = elections.waveNumber;\r\n\t\tnewElectionResult.electionName = elections.electionName;\r\n\t\tnewElectionResult.electionWinner = electionWinner;\r\n\t\tnewElectionResult.signedBy = adminName;\r\n\r\n\t\t// Mark election as finished\r\n\t\telections.isFinished = true;\r\n\t\telections.status = ElectionStatus.Finished;\r\n\r\n\t\t// Store candidates in result\r\n\t\tuint256 candidatesLength = elections.candidates.length;\r\n\t\tfor (uint256 i = 0; i < candidatesLength; ++i) {\r\n\t\t\tCandidateDetail storage candidate = elections.candidates[i];\r\n\t\t\tnewElectionResult.candidates.push(\r\n\t\t\t\tCandidateDetail({\r\n\t\t\t\t\tcandidateID: candidate.candidateID,\r\n\t\t\t\t\tcandidateName: candidate.candidateName,\r\n\t\t\t\t\tcandidateVoteCount: candidate.candidateVoteCount\r\n\t\t\t\t})\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// Update organization data\r\n\t\tuint256 index = findElectionIndex(\r\n\t\t\torganizationData[orgIDs].electionIDs,\r\n\t\t\tpackedElectionID\r\n\t\t);\r\n\r\n\t\torganizationData[orgIDs].electionStatus[index] = ElectionStatus\r\n\t\t\t.Finished;\r\n\r\n\t\t// Use unchecked for simple increment/decrement\r\n\t\t++organizationData[orgIDs].archivedElectionCounter;\r\n\t\t--organizationData[orgIDs].activeElectionCounter;\r\n\t}\r\n\r\n    function findElectionIndex(\r\n\t\tbytes32[] storage array,\r\n\t\tbytes32 electionID\r\n\t) internal view returns (uint256) {\r\n\t\tfor (uint256 i = 0; i < array.length; i++) {\r\n\t\t\tif (array[i] == electionID) {\r\n\t\t\t\treturn i;\r\n\t\t\t}\r\n\t\t}\r\n\t\trevert(\"Election ID not found\");\r\n\t}\r\n\r\n\t// Internal function to handle threshold-passing candidates\r\n\tfunction _handleThresholdCandidates(\r\n\t\tstring memory _userElectionID,\r\n\t\tbytes32 electionIdBytes,\r\n\t\tuint256 passedCandidateCount,\r\n\t\tuint256 _threshold,\r\n\t\tbytes32 packedElectionID\r\n\t) public {\r\n\t\tElectionDetail storage elections = electionInfo[packedElectionID];\r\n\r\n\t\tif (passedCandidateCount < 2) {\r\n\t\t\t// Single candidate passing threshold\r\n\t\t\t_handleSinglePassedCandidate(\r\n\t\t\t\telectionIdBytes,\r\n\t\t\t\telections,\r\n\t\t\t\t_threshold\r\n\t\t\t);\r\n\t\t\treturn;\r\n\t\t} else if (passedCandidateCount > 2) {\r\n\t\t\t// Multiple candidates passing threshold\r\n\r\n\t\t\tuint256 lowestIndex = _findLowestVoteCandidate(elections.candidates);\r\n\t\t\t_removeCandidate(elections.candidates, lowestIndex);\r\n\r\n\t\t\t_resetElectionRound(_userElectionID);\r\n\t\t\tdelete votersList[electionIdBytes];\r\n\t\t\treturn;\r\n\t\t} else {\r\n\t\t\t// Exactly 2 candidates passing threshold\r\n\t\t\tif (elections.waveNumber < 2) {\r\n\t\t\t\t// Early wave (waveNumber 1)\r\n\t\t\t\tfor (uint256 k = 0; k < elections.candidates.length; ++k) {\r\n\t\t\t\t\tif (elections.candidates[k].candidateVoteCount > _threshold) {\r\n\t\t\t\t\t\ttemporalCandidates[electionIdBytes][\r\n\t\t\t\t\t\t\telections.candidates[k].candidateName\r\n\t\t\t\t\t\t].candidateName = elections.candidates[k].candidateName;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tuint256 lowestIndex = _findLowestVoteCandidate(\r\n\t\t\t\t\telections.candidates\r\n\t\t\t\t);\r\n\t\t\t\t_removeCandidate(elections.candidates, lowestIndex);\r\n\r\n\t\t\t\t// Reset for next round\r\n\t\t\t\t_resetElectionRound(_userElectionID);\r\n\t\t\t} else {\r\n\t\t\t\t// Final wave (waveNumber >= 2)\r\n\t\t\t\tuint256 winnerIndex;\r\n\t\t\t\tif (\r\n\t\t\t\t\telections.candidates[0].candidateVoteCount >\r\n\t\t\t\t\telections.candidates[1].candidateVoteCount\r\n\t\t\t\t) {\r\n\t\t\t\t\twinnerIndex = 0;\r\n\t\t\t\t} else if (\r\n\t\t\t\t\telections.candidates[1].candidateVoteCount >\r\n\t\t\t\t\telections.candidates[0].candidateVoteCount\r\n\t\t\t\t) {\r\n\t\t\t\t\twinnerIndex = 1;\r\n\t\t\t\t} else {\r\n\t\t\t\t\telections.isTiedVoting = true;\r\n\t\t\t\t}\r\n\t\t\t\t// Finalize election\r\n\t\t\t\t_finalizeElection(\r\n\t\t\t\t\t_userElectionID,\r\n\t\t\t\t\telectionIdBytes,\r\n\t\t\t\t\telections.orgID,\r\n\t\t\t\t\tbytes32(0),\r\n\t\t\t\t\twinnerIndex\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\r\n\t// Internal function to find the candidate with lowest votes\r\n\tfunction _findLowestVoteCandidate(\r\n\t\tCandidateDetail[] storage candidates\r\n\t) internal view returns (uint256) {\r\n\t\tuint256 lowestVotes = type(uint256).max;\r\n\t\tuint256 lowestIndex;\r\n\t\tuint256 candidatesLength = candidates.length;\r\n\r\n\t\tfor (uint256 k = 0; k < candidatesLength; ++k) {\r\n\t\t\tuint256 currentVotes = candidates[k].candidateVoteCount;\r\n\t\t\tif (currentVotes < lowestVotes) {\r\n\t\t\t\tlowestVotes = currentVotes;\r\n\t\t\t\tlowestIndex = k;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn lowestIndex;\r\n\t}\r\n\r\n\t// Internal function to find the candidate with highest votes that passes a threshold\r\n\tfunction _findHighestVoteCandidateAboveThreshold(\r\n\t\tCandidateDetail[] storage candidates,\r\n\t\tuint256 threshold\r\n\t) internal view returns (uint256) {\r\n\t\tuint256 highestVotes = 0;\r\n\t\tuint256 highestIndex = type(uint256).max; // Invalid index to detect no matches\r\n\t\tuint256 candidatesLength = candidates.length;\r\n\r\n\t\tfor (uint256 k = 0; k < candidatesLength; ++k) {\r\n\t\t\tuint256 currentVotes = candidates[k].candidateVoteCount;\r\n\t\t\tif (currentVotes > threshold && currentVotes > highestVotes) {\r\n\t\t\t\thighestVotes = currentVotes;\r\n\t\t\t\thighestIndex = k;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\trequire(\r\n\t\t\thighestIndex != type(uint256).max,\r\n\t\t\t\"No candidate above threshold\"\r\n\t\t);\r\n\t\treturn highestIndex;\r\n\t}\r\n\r\n\tfunction _handleSinglePassedCandidate(\r\n\t\tbytes32 electionIdBytes,\r\n\t\tElectionDetail storage elections,\r\n\t\tuint256 _threshold\r\n\t) internal {\r\n\t\t// Find the candidate that passed the threshold (should be the highest vote candidate)\r\n\t\tuint256 highestIndex = _findHighestVoteCandidateAboveThreshold(\r\n\t\t\telections.candidates,\r\n\t\t\t_threshold\r\n\t\t);\r\n\t\tCandidateDetail storage thresholdCandidate = elections.candidates[\r\n\t\t\thighestIndex\r\n\t\t];\r\n\r\n\t\t// Save candidate to temporal storage\r\n\t\ttemporalCandidates[electionIdBytes][\r\n\t\t\tthresholdCandidate.candidateName\r\n\t\t] = CandidateDetail({\r\n\t\t\tcandidateID: thresholdCandidate.candidateID,\r\n\t\t\tcandidateName: thresholdCandidate.candidateName,\r\n\t\t\tcandidateVoteCount: thresholdCandidate.candidateVoteCount\r\n\t\t});\r\n\r\n\t\t// Find and remove lowest candidate\r\n\t\tuint256 lowestIndex = _findLowestVoteCandidate(elections.candidates);\r\n\t\t_removeCandidate(elections.candidates, lowestIndex);\r\n\r\n\t\t// Reset votes for next round\r\n\t\tfor (uint256 m = 0; m < elections.candidates.length; ++m) {\r\n\t\t\telections.candidates[m].candidateVoteCount = 0;\r\n\t\t}\r\n\r\n\t\t// Reset voter states\r\n\t\taddress[] storage voterStorage = votersList[electionIdBytes];\r\n\t\tfor (uint256 n = 0; n < voterStorage.length; ++n) {\r\n\t\t\thasVoted[electionIdBytes][voterStorage[n]] = false;\r\n\t\t}\r\n\t\tdelete votersList[electionIdBytes];\r\n\r\n\t\t++elections.waveNumber;\r\n\t\telections.isFinished = false;\r\n\t\temit CandidateStored(\r\n\t\t\telectionIdBytes,\r\n\t\t\tthresholdCandidate.candidateName,\r\n\t\t\tthresholdCandidate.candidateVoteCount\r\n\t\t);\r\n\t}\r\n\r\n    event CandidateStored(\r\n\t\tbytes32 indexed electionId,\r\n\t\tstring candidateName,\r\n\t\tuint256 voteCount\r\n\t);\r\n\r\n    function getAdminName(\r\n\t\taddress adminAddress\r\n\t) private view returns (string memory) {\r\n\t\treturn string(abi.encodePacked(admin[adminAddress].adminName));\r\n\t}\r\n\r\n\t// Internal function to reset for next election round\r\n\tfunction _resetElectionRound(string memory _userElectionID) internal {\r\n\t\tbytes32 electionIdBytes = keccak256(abi.encodePacked(_userElectionID));\r\n\t\tElectionDetail storage elections = electionInfo[\r\n\t\t\tbytes32(abi.encodePacked(_userElectionID))\r\n\t\t];\r\n\r\n\t\t// Reset votes for all candidates\r\n\t\tuint256 candidatesLength = elections.candidates.length;\r\n\t\tfor (uint256 i = 0; i < candidatesLength; ++i) {\r\n\t\t\telections.candidates[i].candidateVoteCount = 0;\r\n\t\t}\r\n\r\n\t\t// Reset voter states\r\n\t\taddress[] storage voterStorage = votersList[electionIdBytes];\r\n\t\tuint256 votersLength = voterStorage.length;\r\n\t\tfor (uint256 j = 0; j < votersLength; ++j) {\r\n\t\t\thasVoted[electionIdBytes][voterStorage[j]] = false;\r\n\t\t}\r\n\t\tdelete votersList[electionIdBytes];\r\n\r\n\t\t// Update election\r\n\t\t++elections.waveNumber;\r\n\t\telections.isFinished = false;\r\n\t}\r\n\r\n\t// Internal function to remove a candidate at specified index\r\n\tfunction _removeCandidate(\r\n\t\tCandidateDetail[] storage candidates,\r\n\t\tuint256 index\r\n\t) internal {\r\n\t\tuint256 lastIndex = candidates.length - 1;\r\n\t\tif (index != lastIndex) {\r\n\t\t\tcandidates[index] = candidates[lastIndex];\r\n\t\t}\r\n\t\tcandidates.pop();\r\n\t}\r\n\r\n\tfunction calculateValidElection(\r\n\t\tstring memory _userElectionID\r\n\t) private view returns (uint256) {\r\n\t\tbytes32 packedElectionID = bytes32(abi.encodePacked(_userElectionID));\r\n\t\tElectionDetail storage elections = electionInfo[packedElectionID];\r\n\t\tuint256 MIN_VOTES_PERCENTAGE = 1 + (elections.totalParticipants / 2);\r\n\r\n\t\treturn MIN_VOTES_PERCENTAGE;\r\n\t}\r\n\r\n    function getElectionInfo(\r\n\t\tstring memory _userElectionID\r\n\t)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (\r\n\t\t\tbytes32 electionID,\r\n\t\t\tstring memory electionName,\r\n\t\t\tuint256 waveNumber,\r\n\t\t\tuint256 totalCandidates,\r\n\t\t\tuint8[] memory candidateIDs, // Added\r\n\t\t\tstring[] memory candidateNames,\r\n\t\t\tuint256[] memory voteCounts,\r\n\t\t\tuint256 totalParticipants,\r\n\t\t\tElectionStatus statusElection,\r\n\t\t\tbool isHaveCandidateMode\r\n\t\t)\r\n\t{\r\n\t\tbytes32 userElectionID = bytes32(abi.encodePacked(_userElectionID));\r\n\r\n\t\tElectionDetail storage election = electionInfo[userElectionID];\r\n\t\trequire(bytes32(election.electionID).length > 0);\r\n\r\n\t\telectionID = election.electionID;\r\n\t\telectionName = string(abi.encodePacked(election.electionName));\r\n\t\twaveNumber = election.waveNumber;\r\n\t\ttotalCandidates = election.candidates.length;\r\n\t\tcandidateIDs = new uint8[](totalCandidates); // Initialized\r\n\t\tcandidateNames = new string[](totalCandidates);\r\n\t\tvoteCounts = new uint256[](totalCandidates);\r\n\t\ttotalParticipants = election.totalParticipants;\r\n\t\tstatusElection = electionInfo[userElectionID].status;\r\n\t\tisHaveCandidateMode = electionInfo[userElectionID].isHaveCandidateMode;\r\n\r\n\t\tfor (uint256 i = 0; i < totalCandidates; ++i) {\r\n\t\t\tcandidateIDs[i] = election.candidates[i].candidateID; // Added\r\n\t\t\tcandidateNames[i] = election.candidates[i].candidateName;\r\n\t\t\tvoteCounts[i] = election.candidates[i].candidateVoteCount;\r\n\t\t}\r\n\r\n\t\treturn (\r\n\t\t\telectionID,\r\n\t\t\telectionName,\r\n\t\t\twaveNumber,\r\n\t\t\ttotalCandidates,\r\n\t\t\tcandidateIDs,\r\n\t\t\tcandidateNames,\r\n\t\t\tvoteCounts,\r\n\t\t\ttotalParticipants,\r\n\t\t\tstatusElection,\r\n\t\t\tisHaveCandidateMode\r\n\t\t);\r\n\t}\r\n\r\n\tfunction getCandidateResult(\r\n\t\tstring memory _electionID\r\n\t)\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns (\r\n\t\t\tuint8[] memory candidateID,\r\n\t\t\tstring[] memory candidateName,\r\n\t\t\tuint256[] memory candidateVoteCount\r\n\t\t)\r\n\t{\r\n\t\tuint totalCandidates = electionResults[_electionID].candidates.length;\r\n\r\n\t\tuint8[] memory candidateIDs = new uint8[](totalCandidates);\r\n\t\tstring[] memory candidateNames = new string[](totalCandidates);\r\n\t\tuint256[] memory candidateVoteCounts = new uint256[](totalCandidates);\r\n\r\n\t\tfor (uint i = 0; i < totalCandidates; i++) {\r\n\t\t\tcandidateIDs[i] = electionResults[_electionID]\r\n\t\t\t\t.candidates[i]\r\n\t\t\t\t.candidateID;\r\n\t\t\tcandidateNames[i] = electionResults[_electionID]\r\n\t\t\t\t.candidates[i]\r\n\t\t\t\t.candidateName;\r\n\t\t\tcandidateVoteCounts[i] = electionResults[_electionID]\r\n\t\t\t\t.candidates[i]\r\n\t\t\t\t.candidateVoteCount;\r\n\t\t}\r\n\r\n\t\treturn (candidateIDs, candidateNames, candidateVoteCounts);\r\n\t}\r\n}"
    },
    "contracts/Ultimate_VotreXSystemRC2A.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// pragma abicoder v2;\npragma solidity ^0.8.24;\n\nimport \"./UtilityLibrary.sol\";\n\ncontract TestCompleXA2{\n\n    using UtilityLibrary for *;\n\n    constructor(){\n        VotreXOwnerAddress = msg.sender;\n        VotreXActivated = false;\n    }\n\n    uint256 private organizationsCounter;\n    bool private VotreXActivated;\n    address private previousVotreXOwnerAddress;\n    address private VotreXOwnerAddress;\n    bytes32 public VotreXOwnerName = keccak256(abi.encodePacked(\"ATom\"));\n    uint256 private VotreXUserCounter;\n    // uint256 private OrganizationPriceFee = 20 ether;\n    \n    mapping(string  => Organization) public organizationData;\n    mapping(address => ElectionAdmins) public admin;\n    mapping(address => Voter) public voters;\n    mapping(bytes32 => ElectionDetail) public electionInfo;\n    mapping(string  => ElectionResult) public electionResults;\n    mapping(bytes32 => bool) private electionExistanceChecks;\n    mapping(bytes16 => bool) private votersIDExists;\n    mapping(address => bool) private registeredAdmin;\n\n    enum ElectionStatus {\n        Preparation,\n        Scheduled,\n        Started,\n        Finished\n    }\n\n    enum OrganizationType {\n        Organization,\n        Corporate\n    }\n\n    struct Organization {\n        OrganizationType orgType;\n        address electionAdminAddresses;\n        uint256 onPreparationElectionCounter;\n        uint256 activeElectionCounter;\n        uint256 archivedElectionCounter;\n        uint256 totalMembers;\n        bytes32 orgName;\n        string orgID;\n        bytes32[] electionIDs;\n        bytes32[] ElectionName;\n        ElectionStatus[] electionStatus;\n    }\n\n    struct ElectionAdmins {\n        bool isRegistered;\n        uint8 adminOrgCount;\n        bytes10 AdminVoterIDOrg1;\n        bytes10 AdminVoterIDOrg2;\n        address electionAdminAddress;\n        uint256 nextOrgCreationBlock;\n        bytes32 adminName;\n        string RegisteredOrgID1;\n        string RegisteredOrgID2;\n    }\n\n    struct ElectionResult {\n        bool isPruned;\n        address adminAddress;\n        uint startTime;\n        uint endTime;\n        uint totalVoter;\n        bytes32 electionID;\n        bytes32 electionName;\n        bytes32 digitalSignature;\n        string registeredOrganization;\n        string electionWinner;\n        string signedBy;\n        CandidateDetail[] candidates;\n    }\n    \n    struct Voter{\n        bool isRegistered;\n        address VoterAddress;\n        bytes16 VoterIDOrg1;\n        bytes16 VoterIDOrg2;\n        string VoterName;\n        string RegisteredOrgID1;\n        string RegisteredOrgID2;\n        string[] participatedElectionEvents;\n    }\n\n    struct ElectionDetail{\n        ElectionStatus status;\n        uint8 candidateList;\n        bool isFinished;\n        bytes32 electionID;\n        bytes32 electionName;\n        uint startTime;\n        uint endTime;\n        string orgID;\n        uint256 totalParticipants;\n        CandidateDetail[] candidates;\n    }\n\n    struct CandidateDetail{\n        uint8 candidateID;\n        uint256 candidateVoteCount;\n        string candidateName;\n    }\n\n    modifier onlyOrgAdmin(string memory _IDParameters) {\n        bool isAdminRegisteredForOrg = false;\n        if (\n            keccak256(abi.encodePacked(admin[msg.sender].RegisteredOrgID1))\n            ==\n            keccak256(abi.encodePacked(_IDParameters))\n            ||\n            keccak256(abi.encodePacked(admin[msg.sender].RegisteredOrgID2))\n            ==\n            keccak256(abi.encodePacked(_IDParameters))\n        ) {\n            isAdminRegisteredForOrg = true;\n        } else if (\n            bytes32(abi.encodePacked(admin[msg.sender].RegisteredOrgID1))\n            !=\n            bytes32(abi.encodePacked(_IDParameters))\n            ||\n            bytes32(abi.encodePacked(admin[msg.sender].RegisteredOrgID2))\n            !=\n            bytes32(abi.encodePacked(_IDParameters))\n        ) {\n            string memory orgID = UtilityLibrary.extractOrgId(_IDParameters);\n            isAdminRegisteredForOrg = true;\n\n        }\n\n        require(\n            isAdminRegisteredForOrg,\n            \"error:31a\"\n        );\n        _;\n    }\n\n    modifier onlyAuthorizedMember(string memory _userElectionID) {\n        string memory orgID = UtilityLibrary.extractOrgId(_userElectionID);\n\n        bool isAdminRegisteredForOrg = (\n            keccak256(abi.encodePacked(admin[msg.sender].RegisteredOrgID1))\n            ==\n            keccak256(abi.encodePacked(orgID))\n        )||(\n            keccak256(abi.encodePacked(admin[msg.sender].RegisteredOrgID2))\n            ==\n            keccak256(abi.encodePacked(orgID))\n        );\n\n        bool isVoterRegisteredForOrg = (\n            keccak256(abi.encodePacked(voters[msg.sender].RegisteredOrgID1))\n            ==\n            keccak256(abi.encodePacked(orgID))\n        )||(\n            keccak256(abi.encodePacked(voters[msg.sender].RegisteredOrgID2))\n            ==\n            keccak256(abi.encodePacked(orgID))\n        );\n\n        require(\n            isAdminRegisteredForOrg || isVoterRegisteredForOrg,\n            // error 31a = Incorrect access control\n            \"error:31a\"\n        );\n        _;\n    }\n\n    modifier canCreateOrg() {\n        require(\n            block.number >= admin[msg.sender].nextOrgCreationBlock,\n            // error 32 = error Block await for 2nd Admin Org Registration\n            \"error:32\"\n        );\n        _;\n    }\n\n    modifier onlyVotreXOwner() {\n        require(\n            msg.sender == VotreXOwnerAddress,\n            // error 31b = errror Owner access\n            \"error:31b\"\n        );\n        _;\n    }\n\n    modifier onlyWhenActivated() {\n        require(\n            VotreXActivated == true,\n            // error 33 = error system still disabled\n            \"error:33\"\n        );\n        _;\n    }\n\n    function CheckTokenETHBalance () external view onlyVotreXOwner returns (uint256) {\n        return (address(this).balance);\n    }\n\n    function changeSystemState() external onlyVotreXOwner{\n        if (VotreXActivated == false) {\n            VotreXActivated = true;\n        } else {\n            VotreXActivated = false;\n        }\n    }\n\n    // function setOrgPriceFee(uint256 _PriceinEther) external onlyVotreXOwner {\n    //     OrganizationPriceFee = _PriceinEther * 1 ether;\n    // }\n\n    // receive() external payable {\n\n    // }\n\n    function registerOrganization(\n        string memory _orgName,\n        string memory _orgID,\n        string memory _adminName,\n        OrganizationType _orgType\n    )\n        external\n        payable\n        canCreateOrg\n        onlyWhenActivated\n    {\n        ElectionAdmins storage AdminInfo = admin[msg.sender];\n\n        // require(\n        //     msg.value == OrganizationPriceFee,\n        //     // error 34 = error wrong ether value being sent\n        //     \"error:34\"\n        // );\n\n        require(\n            organizationsCounter < 32000,\n            // error 35 = error limit reached\n            \"error:35\"\n        );\n\n        require(\n            bytes32(organizationData[_orgID].orgName).length > 0,\n            // error 36a = error incorrect null value\n            \"error:36a\"\n        );\n\n        require(\n            organizationData[_orgID].electionAdminAddresses == address(0),\n            // error 36a = error incorrect null value\n            \"error:36a\"\n        );\n\n        require(\n            UtilityLibrary.onlyAlphanumericCharacters(_orgID),\n            // error36b = Only Alpha Numeric character allowed\n            \"error:36b\"\n        );\n\n        require(\n            bytes(_orgName).length > 0,\n            // error 36a = error incorrect null value\n            \"error:36a\"\n        );\n\n        require(\n            bytes(_orgName).length < 32,\n            // error 36c = error character length limit\n\n            \"error:36c\"\n        );\n\n        require(\n            bytes(_adminName).length > 1\n        );\n\n        require(\n            bytes(_orgID).length == 3 || bytes(_orgID).length == 4,\n            \"Org ID should 3 or 4 characters\"\n        );\n\n        require(\n            keccak256(abi.encodePacked(admin[msg.sender].RegisteredOrgID1))\n            !=\n            keccak256(abi.encodePacked(_orgID))\n            &&\n            keccak256(abi.encodePacked(admin[msg.sender].RegisteredOrgID2))\n            !=\n            keccak256(abi.encodePacked(_orgID)),\n            \"Admin is registered\"\n        );\n\n        Organization storage newOrg = organizationData[_orgID];\n        newOrg.orgID = _orgID;\n        newOrg.orgName = bytes32(abi.encodePacked(_orgName));\n        newOrg.orgType = _orgType;\n        newOrg.electionAdminAddresses = msg.sender;\n        newOrg.activeElectionCounter = 0;\n        newOrg.totalMembers = 1;\n\n        bytes10 UniqueAdminvoterID = bytes10(abi.encodePacked(_orgID, \"-\", \"Admin\"));\n\n        if (bytes(admin[msg.sender].RegisteredOrgID1).length == 0) {\n            admin[msg.sender].RegisteredOrgID1 = _orgID;\n            admin[msg.sender].AdminVoterIDOrg1 = UniqueAdminvoterID;\n        } else if (bytes(admin[msg.sender].RegisteredOrgID2).length == 0) {\n            admin[msg.sender].RegisteredOrgID2 = _orgID;\n            admin[msg.sender].AdminVoterIDOrg2 = UniqueAdminvoterID;\n        }\n\n        AdminInfo.electionAdminAddress = msg.sender;\n        AdminInfo.adminName = bytes32(abi.encodePacked(_adminName));\n        AdminInfo.isRegistered = true;\n        ++AdminInfo.adminOrgCount;\n\n        registeredAdmin[msg.sender] = true;\n        votersIDExists[UniqueAdminvoterID] = true;\n\n        AdminInfo.nextOrgCreationBlock = 50 + block.number;\n\n        ++organizationsCounter;\n        ++VotreXUserCounter;\n    }\n\n    function registerVoter(\n        string memory _voterName,\n        string memory _orgID,\n        bytes32 uniqueVoterID\n    )\n        external\n        payable\n        onlyWhenActivated\n    {\n        // require(\n        //     msg.value == (OrganizationPriceFee/2)\n        // );\n\n        Voter storage voter = voters[msg.sender];\n        // string memory uniqueVoterID = generateUniqueVoterID(_orgID);\n        bytes16 VoterID16 = bytes16(abi.encodePacked(uniqueVoterID));\n        // bytes32 orgIDs = keccak256(abi.encodePacked(_orgID));\n\n        require(\n            organizationData[_orgID].totalMembers < 5000,\n            \"Maximum member limit reached\"\n        );\n\n        require(\n            bytes(_voterName).length > 1,\n            \"Please fill Voter Name\"\n        );\n\n        require(\n            bytes(_voterName).length < 24,\n            \"Voter name limit is 24 characters\"\n        );\n\n        require(\n            keccak256(abi.encodePacked(voters[msg.sender].RegisteredOrgID1))\n            !=\n            keccak256(abi.encodePacked(_orgID))\n            &&\n            keccak256(abi.encodePacked(voters[msg.sender].RegisteredOrgID2))\n            !=\n            keccak256(abi.encodePacked(_orgID))\n            &&\n            !registeredAdmin[msg.sender],\n            \"Voter is registered in Org\"\n        );\n\n        require(\n            ElectionActiveCheck(_orgID) < 1,\n            \"Election in progress!\"\n        );\n\n        require(\n            bytes16(uniqueVoterID).length > 0\n        );\n\n        require(\n            bytes(organizationData[_orgID].orgID).length != 0,\n            \"Organization does not exist\"\n        );\n\n        if (bytes(voter.RegisteredOrgID1).length == 0) {\n            voter.RegisteredOrgID1 = _orgID;\n            voter.VoterIDOrg1 = VoterID16;\n        } else if (bytes(voter.RegisteredOrgID2).length == 0) {\n            voter.RegisteredOrgID2 = _orgID;\n            voter.VoterIDOrg2 = VoterID16;\n        }\n\n        voter.VoterAddress = msg.sender;\n        voter.VoterName = _voterName;\n        voter.participatedElectionEvents = new string[](0);\n        voter.isRegistered = true;\n        votersIDExists[VoterID16] = true;\n        ++VotreXUserCounter;\n        ++organizationData[_orgID].totalMembers;\n    }\n\n    function createElection(\n        string memory _orgID,\n        string memory _userElectionID,\n        string memory _electionName,\n        uint8 _candidateCount\n    )\n        external\n        onlyWhenActivated\n        onlyOrgAdmin(_orgID)\n    {\n        require(\n            bytes(organizationData[_orgID].orgID).length > 0\n        );\n\n        require(\n            bytes(_userElectionID).length > 1,\n            // error 36a = error incorrect null value\n            \"error 36a\"\n        \n        );\n\n        require(\n            bytes(_userElectionID).length < 5,\n            \"ID should < 5 characters\"\n        );\n\n        require(\n            bytes(_electionName).length > 1\n        );\n\n        require(\n            bytes(_electionName).length < 25,\n            \"Election name should < 25\"\n        );\n\n        require(\n            organizationData[_orgID].activeElectionCounter < 10,\n            \"Maximum events reached\"\n        );\n\n        require(_candidateCount > 1, \"Minimum 2 candidates!\");\n\n        bytes32 generatedElectionID = bytes32(abi.encodePacked(_orgID, \"-\", _userElectionID));\n        ElectionDetail storage newElection = electionInfo[generatedElectionID];\n\n        require(\n            !electionExistanceChecks[generatedElectionID],\n            \"Election ID exists\"\n        );\n\n        newElection.orgID = _orgID;\n        newElection.electionID = generatedElectionID;\n        newElection.electionName = bytes32(abi.encodePacked(_electionName));\n        newElection.candidateList = _candidateCount;\n        newElection.status = ElectionStatus.Preparation;\n        electionExistanceChecks[generatedElectionID] = true;\n        organizationData[_orgID].electionIDs.push(generatedElectionID);\n        organizationData[_orgID].ElectionName.push(bytes32(abi.encodePacked(_electionName)));\n        organizationData[_orgID].electionStatus.push(ElectionStatus.Preparation);\n        ++organizationData[_orgID].onPreparationElectionCounter;\n    }\n\n    function startElection(string memory _userElectionID) external onlyOrgAdmin(_userElectionID){\n        // error 36a = error incorrect null value\n        require(bytes(_userElectionID).length > 0, \"error:36a\");\n\n        bytes32 userElectionID = bytes32(abi.encodePacked(_userElectionID));\n        string memory orgIDs = UtilityLibrary.extractOrgId(_userElectionID);\n\n        ElectionDetail storage election = electionInfo[userElectionID];\n        require(bytes16(election.electionID).length > 0, \"Invalid election ID\");\n        require(election.status == ElectionStatus.Preparation, \"Election is not in preparation\");\n        require(election.candidateList == election.candidates.length, \"Candidate Not full\");\n\n        election.startTime = 5 + block.timestamp;\n        election.status = ElectionStatus.Started;\n        ++organizationData[orgIDs].activeElectionCounter;\n        --organizationData[orgIDs].onPreparationElectionCounter;\n        uint256 index = findElectionIndex(organizationData[orgIDs].electionIDs, userElectionID);\n        require(index < organizationData[orgIDs].electionIDs.length, \"Election not found\");\n        organizationData[orgIDs].electionStatus[index] = ElectionStatus.Started;\n    }\n\n    function findElectionIndex(bytes32[] storage array, bytes32 electionID) internal view returns (uint256) {\n        for (uint256 i = 0; i < array.length; i++) {\n            if (array[i] == electionID) {\n                return i;\n            }\n        }\n        revert(\"Election ID not found\");\n    }\n\n    function finishElection(string memory _userElectionID, bytes32 _dataHash)\n        external\n        onlyOrgAdmin(_userElectionID)\n    {\n        bytes32 packedElectionID = bytes32(abi.encodePacked(_userElectionID));\n        ElectionDetail storage elections = electionInfo[packedElectionID];\n        string memory orgIDs = UtilityLibrary.extractOrgId(_userElectionID);\n        string memory adminName = getAdminName(msg.sender);\n        string memory electionWinner = determineWinner(_userElectionID);\n\n        require(\n            bytes(_userElectionID).length > 0,\n            \"Invalid election ID\"\n        );\n\n        require(\n            bytes(_userElectionID).length > 0,\n            \"Election ID can't be empty\"\n        );\n\n        require(\n            bytes32(electionInfo[packedElectionID].electionID).length > 0,\n            \"error:36a\"\n        );\n\n        require(\n            _dataHash.length > 0,\n            \"error:36a\"\n        );\n\n        require(!elections.isFinished, \"Election finished\");\n\n        require(\n            elections.status == ElectionStatus.Started,\n            \"Election is not started\"\n        );\n\n        require(\n            elections.totalParticipants > calculateValidElection(_userElectionID),\n            \"need 50% total member to finish\"\n        );\n\n        elections.endTime = 5 + block.timestamp;\n        elections.status = ElectionStatus.Finished;\n        elections.isFinished = true;\n\n        ElectionResult storage newelectionResult = electionResults[_userElectionID];\n        newelectionResult.isPruned = true;\n        newelectionResult.totalVoter = elections.totalParticipants;\n        newelectionResult.adminAddress = msg.sender;\n        newelectionResult.startTime = elections.startTime;\n        newelectionResult.endTime = elections.endTime;\n        newelectionResult.digitalSignature = _dataHash;\n        newelectionResult.registeredOrganization = elections.orgID;\n        newelectionResult.electionID = packedElectionID;\n        newelectionResult.electionName = elections.electionName;\n        newelectionResult.electionWinner = electionWinner;\n        newelectionResult.signedBy = adminName;\n\n        for (uint i = 0; i < elections.candidates.length; i++) {\n            CandidateDetail memory candidate = elections.candidates[i];\n            newelectionResult.candidates.push(\n                CandidateDetail({\n                    candidateID: candidate.candidateID,\n                    candidateName: candidate.candidateName,\n                    candidateVoteCount: candidate.candidateVoteCount\n                })\n            );\n        }\n\n        delete electionInfo[packedElectionID];\n        uint256 index = findElectionIndex(organizationData[orgIDs].electionIDs, packedElectionID);\n        organizationData[orgIDs].electionStatus[index] = ElectionStatus.Finished;\n        ++organizationData[orgIDs].archivedElectionCounter;\n        --organizationData[orgIDs].activeElectionCounter;\n    }\n\n\n    function calculateValidElection(string memory _userElectionID)\n        private\n        view\n        returns (uint256)\n    {\n        string memory orgID = UtilityLibrary.extractOrgId(_userElectionID);\n        Organization storage OrgData = organizationData[orgID];\n        uint256 MIN_VOTES_PERCENTAGE = 1 + (OrgData.totalMembers / 2);\n\n        return MIN_VOTES_PERCENTAGE;\n    }\n\n    function getOwnerAddress() external view returns (address) {\n        return VotreXOwnerAddress;\n    }\n\n    function getOwnerName() external view returns (bytes32) {\n        return VotreXOwnerName;\n    }\n\n    function getTotalUser() external view returns (uint256) {\n        return VotreXUserCounter;\n    }\n\n    function getElectionListInOrg(string memory orgID)\n        public\n        view\n        returns (bytes32[] memory, bytes32[] memory, ElectionStatus[] memory)\n    {\n        Organization storage org = organizationData[orgID];\n        return (org.electionIDs, org.ElectionName, org.electionStatus);\n    }\n\n    function getAdminName(address adminAddress) private view returns (string memory) {\n        return string(abi.encodePacked(admin[adminAddress].adminName));\n    }\n\n    function addCandidateDetail(\n        string memory _userElectionID,\n        string memory _candidateName\n    )\n        external\n        onlyOrgAdmin(_userElectionID)\n    {\n        bytes32 userElectionID = bytes32(abi.encodePacked(_userElectionID));\n        ElectionDetail storage election = electionInfo[userElectionID];\n\n        require(bytes(_userElectionID).length > 0);\n\n        require(\n            bytes32(electionInfo[userElectionID].electionID).length > 0,\n            // error 36a = error incorrect null value\n            \"error:36a\"\n        );\n\n        require(\n            election.candidates.length < election.candidateList,\n            \"Candidate limit reached\"\n        );\n\n        require(bytes(_candidateName).length > 0);\n\n        require(\n            bytes(_candidateName).length <= 24,\n            \"name limits 24 characters\"\n        );\n\n        require(\n            UtilityLibrary.allowWhiteSpace(_candidateName),\n            \"Candidate name can only contain alphabetical\"\n        );\n\n        uint8 candidateID = uint8(election.candidates.length);\n\n        election.candidates.push(\n            CandidateDetail({\n                candidateID: candidateID,\n                candidateName: _candidateName,\n                candidateVoteCount: 0\n            })\n        );\n    }\n\n    function vote(\n        string memory _userElectionID,\n        uint8 candidateID\n    )\n        external\n        onlyWhenActivated\n        onlyAuthorizedMember(_userElectionID)\n    {\n        bytes32 userElectionID = bytes32(abi.encodePacked(_userElectionID));\n        ElectionDetail storage election = electionInfo[userElectionID];\n        Voter storage voter = voters[msg.sender];\n        bytes32 electionName = election.electionName;\n        require(bytes(_userElectionID).length > 0, \"Election ID can't be empty\");\n        require(candidateID < election.candidates.length, \"Invalid candidate ID\");\n        require(election.status == ElectionStatus.Started, \"Election is not in progress\");\n        require(!hasParticipatedInElection(msg.sender, electionName), \"You already voted in this election\");\n\n        ++election.candidates[candidateID].candidateVoteCount;\n        voter.participatedElectionEvents = UtilityLibrary.appendToStringArray(\n            voter.participatedElectionEvents,\n            string(abi.encodePacked(election.electionName))\n        );\n        ++election.totalParticipants;\n    }\n\n\n    function withdrawFees() external onlyVotreXOwner{\n        require(address(this).balance > 0, \"No FLR Balance in Contract\");\n        payable(VotreXOwnerAddress).transfer(address(this).balance);\n    }\n\n    function isVotreXActivated() external onlyVotreXOwner view returns (bool) {\n        return VotreXActivated;\n    }\n\n    // function getRegistrationFee() external view returns (uint256){\n    //     return OrganizationPriceFee;\n    // }\n\n    function getTotalOrganization() external virtual view returns (uint256) {\n        return organizationsCounter;\n    }\n\n    function getelectionInfo(string memory _userElectionID)\n        external\n        view\n        returns(\n            bytes32 electionID,\n            string memory electionName,\n            uint256 totalCandidates,\n            uint8[] memory candidateIDs, // Added\n            string[] memory candidateNames,\n            uint256[] memory voteCounts,\n            uint256 totalParticipants,\n            ElectionStatus statusElection\n        )\n    {\n        bytes32 userElectionID = bytes32(abi.encodePacked(_userElectionID));\n\n        ElectionDetail storage election = electionInfo[userElectionID];\n        require(\n            bytes32(election.electionID).length > 0\n        );\n\n        electionID = election.electionID;\n        electionName = string(abi.encodePacked(election.electionName));\n        totalCandidates = election.candidates.length;\n        candidateIDs = new uint8[](totalCandidates); // Initialized\n        candidateNames = new string[](totalCandidates);\n        voteCounts = new uint256[](totalCandidates);\n        statusElection = electionInfo[userElectionID].status;\n        totalParticipants = election.totalParticipants;\n\n        for (uint256 i = 0; i < totalCandidates; ++i) {\n            candidateIDs[i] = election.candidates[i].candidateID; // Added\n            candidateNames[i] = election.candidates[i].candidateName;\n            voteCounts[i] = election.candidates[i].candidateVoteCount;\n        }\n\n        return (\n            electionID,\n            electionName,\n            totalCandidates,\n            candidateIDs,\n            candidateNames,\n            voteCounts,\n            totalParticipants,\n            statusElection\n        );\n    }\n\n    function getCandidateResult(string memory _electionID) \n        public \n        view \n        returns (\n            uint8[] memory candidateID,\n            string[] memory candidateName,\n            uint256[] memory candidateVoteCount\n        ) \n    {\n\n        uint totalCandidates = electionResults[_electionID].candidates.length;\n\n        uint8[] memory candidateIDs = new uint8[](totalCandidates);\n        string[] memory candidateNames = new string[](totalCandidates);\n        uint256[] memory candidateVoteCounts = new uint256[](totalCandidates);\n\n        for (uint i = 0; i < totalCandidates; i++) {\n            candidateIDs[i] = electionResults[_electionID].candidates[i].candidateID;\n            candidateNames[i] = electionResults[_electionID].candidates[i].candidateName;\n            candidateVoteCounts[i] = electionResults[_electionID].candidates[i].candidateVoteCount;\n        }\n\n        return (\n            candidateIDs,\n            candidateNames,\n            candidateVoteCounts\n        );\n    }\n\n    function getUserInfo() external view returns (\n        bool isRegistered,\n        bool isAdmin,\n        address userAddress,\n        string memory userName,\n        string[] memory registeredOrgList,\n        string[] memory voterIDList,\n        string[] memory participatedElectionEvents\n    ) {\n        userAddress = msg.sender;\n\n        if (admin[userAddress].isRegistered) {\n            ElectionAdmins storage adminInfo = admin[userAddress];\n            \n            string[] memory VoterRegisteredOrgList = new string[](2);\n            VoterRegisteredOrgList[0] = adminInfo.RegisteredOrgID1;\n            VoterRegisteredOrgList[1] = adminInfo.RegisteredOrgID2;\n\n            string[] memory VoterIDList = new string[](2);\n            VoterIDList[0] = string(abi.encodePacked(adminInfo.AdminVoterIDOrg1));\n            VoterIDList[1] = string(abi.encodePacked(adminInfo.AdminVoterIDOrg2));\n\n            return (\n                true,\n                true,\n                userAddress,\n                string(abi.encodePacked(adminInfo.adminName)),\n                VoterRegisteredOrgList,\n                VoterIDList,\n                new string[](0)\n            );\n\n        } else if (voters[userAddress].isRegistered) {\n            Voter storage voter = voters[userAddress];\n\n            string[] memory RegisteredOrgIDList = new string[](2);\n            RegisteredOrgIDList[0] = voter.RegisteredOrgID1;\n            RegisteredOrgIDList[1] = voter.RegisteredOrgID2;\n\n            string[] memory RegisteredVoterIDList = new string[](2);\n            RegisteredVoterIDList[0] = string(abi.encodePacked(voter.VoterIDOrg1));\n            RegisteredVoterIDList[1] = string(abi.encodePacked(voter.VoterIDOrg2));\n            return (\n                true,\n                false,\n                userAddress,\n                voter.VoterName,\n                RegisteredOrgIDList,\n                RegisteredVoterIDList,\n                voter.participatedElectionEvents\n            );\n        } else {\n            return (\n                false,\n                false,\n                userAddress,\n                \"\",\n                new string[](0),\n                new string[](0),\n                new string[](0)\n            );\n        }\n    }\n\n    function ElectionActiveCheck(string memory _orgID) private view returns (uint256) {\n\n        return organizationData[_orgID].activeElectionCounter;\n    \n    }\n\n    function hasParticipatedInElection(\n        address voterAddress,\n        bytes32 electionName\n    )\n        private\n        view\n        returns (bool)\n    {\n        Voter storage voter = voters[voterAddress];\n        for (uint i = 0; i < voter.participatedElectionEvents.length; ++i) {\n            if (\n                keccak256(abi.encodePacked(voter.participatedElectionEvents[i]))\n                ==\n                keccak256(abi.encodePacked(electionName))\n            ) {\n                return true; \n            }\n        }\n\n        return false; \n    }\n\n    function determineWinner(string memory _userElectionID) private view returns (string memory) {\n        bytes32 userElectionID = bytes32(abi.encodePacked(_userElectionID));\n        ElectionDetail storage election = electionInfo[userElectionID];\n        string memory winner = \"\";\n        uint256 maxVotes = 0;\n        for (uint8 i = 0; i < election.candidates.length; ++i) {\n            if (election.candidates[i].candidateVoteCount > maxVotes) {\n                maxVotes = election.candidates[i].candidateVoteCount;\n                winner = election.candidates[i].candidateName;\n            }\n        }\n\n        return winner;\n    }\n    \n    // function generateUniqueVoterID(string memory _orgID) public view returns (string memory) {\n    //     uint256 CurrentID = organizationData[_orgID].totalMembers;\n    //     uint256 nextID = ++CurrentID;\n\n    //     return string(abi.encodePacked(_orgID, \"-\", UtilityLibrary.uint2str(nextID)));\n    // }\n\n    function getOrgIDHash(string memory _orgID) external pure returns (bytes32) {\n        bytes32 orgIDHash = keccak256(abi.encodePacked(_orgID));\n\n        return (orgIDHash);\n    }\n}\n"
    },
    "contracts/Ultimate_VotreXSystemRC2B.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// pragma abicoder v2;\npragma solidity ^0.8.24;\n\nimport \"./UtilityLibrary.sol\";\n\ncontract TestCompleXA2B{\n\n    using UtilityLibrary for *;\n\n    constructor(){\n        VotreXOwnerAddress = msg.sender;\n        VotreXActivated = true;\n    }\n    bool private VotreXActivated;\n    address private previousVotreXOwnerAddress;\n    address private VotreXOwnerAddress;\n    bytes32 public VotreXOwnerName = keccak256(abi.encodePacked(\"ATom\"));\n    uint256 private organizationsCounter;\n    uint256 private VotreXUserCounter;\n    // uint256 private OrganizationPriceFee = 20 ether;\n    \n    mapping(string  => Organization) public organizationData;\n    mapping(address => ElectionAdmins) public admin;\n    mapping(address => Voter) public voters;\n    mapping(bytes32 => ElectionDetail) public electionInfo;\n    mapping(string  => ElectionResult) public electionResults;\n    mapping(bytes32 => mapping(address => bool)) public hasVoted;\n    mapping(bytes32 => bool) private electionExistanceChecks;\n    mapping(bytes16 => bool) private votersIDExists;\n    mapping(bytes32 => address[]) private votersList;\n    mapping(address => bool) private registeredAdmin;\n    mapping(string => bool) private registeredCandidate;\n    string[] private candidateList;\n\n    enum ElectionStatus {\n        Preparation,\n        Scheduled,\n        Started,\n        Finished\n    }\n\n    enum OrganizationType {\n        Organization,\n        Corporate\n    }\n\n    struct Organization {\n        OrganizationType orgType;\n        address electionAdminAddresses;\n        uint256 onPreparationElectionCounter;\n        uint256 activeElectionCounter;\n        uint256 archivedElectionCounter;\n        uint256 totalMembers;\n        bytes32 orgName;\n        string orgID;\n        bytes32[] electionIDs;\n        bytes32[] ElectionName;\n        ElectionStatus[] electionStatus;\n    }\n\n    struct ElectionAdmins {\n        bool isRegistered;\n        uint8 adminOrgCount;\n        bytes10 AdminVoterIDOrg1;\n        bytes10 AdminVoterIDOrg2;\n        address electionAdminAddress;\n        uint256 nextOrgCreationBlock;\n        bytes32 adminName;\n        string RegisteredOrgID1;\n        string RegisteredOrgID2;\n    }\n\n    struct ElectionResult {\n        bool isPruned;\n        address adminAddress;\n        uint256 waveNumber;\n        uint startTime;\n        uint endTime;\n        uint totalVoter;\n        bytes32 electionID;\n        bytes32 electionName;\n        bytes32 digitalSignature;\n        string registeredOrganization;\n        string electionWinner;\n        string signedBy;\n        CandidateDetail[] candidates;\n    }\n    \n    struct Voter{\n        bool isRegistered;\n        address VoterAddress;\n        bytes16 VoterIDOrg1;\n        bytes16 VoterIDOrg2;\n        string VoterName;\n        string RegisteredOrgID1;\n        string RegisteredOrgID2;\n        string[] participatedElectionEvents;\n    }\n\n    struct ElectionDetail{\n        ElectionStatus status;\n        uint8 candidateList;\n        bool isFinished;\n        bytes32 electionID;\n        bytes32 electionName;\n        uint startTime;\n        uint endTime;\n        string orgID;\n        uint256 totalParticipants;\n        uint256 waveNumber;\n        CandidateDetail[] candidates;\n    }\n\n    struct CandidateDetail{\n        uint8 candidateID;\n        uint256 candidateVoteCount;\n        string candidateName;\n    }\n\n    modifier onlyOrgAdmin(string memory _IDParameters) {\n        bool isAdminRegisteredForOrg = false;\n        if (\n            keccak256(abi.encodePacked(admin[msg.sender].RegisteredOrgID1))\n            ==\n            keccak256(abi.encodePacked(_IDParameters))\n            ||\n            keccak256(abi.encodePacked(admin[msg.sender].RegisteredOrgID2))\n            ==\n            keccak256(abi.encodePacked(_IDParameters))\n        ) {\n            isAdminRegisteredForOrg = true;\n        } else if (\n            bytes32(abi.encodePacked(admin[msg.sender].RegisteredOrgID1))\n            !=\n            bytes32(abi.encodePacked(_IDParameters))\n            ||\n            bytes32(abi.encodePacked(admin[msg.sender].RegisteredOrgID2))\n            !=\n            bytes32(abi.encodePacked(_IDParameters))\n        ) {\n            string memory orgID = UtilityLibrary.extractOrgId(_IDParameters);\n            isAdminRegisteredForOrg = true;\n\n        }\n\n        require(\n            isAdminRegisteredForOrg,\n            \"error:31a\"\n        );\n        _;\n    }\n\n    modifier onlyAuthorizedMember(string memory _userElectionID) {\n        string memory orgID = UtilityLibrary.extractOrgId(_userElectionID);\n\n        bool isAdminRegisteredForOrg = (\n            keccak256(abi.encodePacked(admin[msg.sender].RegisteredOrgID1))\n            ==\n            keccak256(abi.encodePacked(orgID))\n        )||(\n            keccak256(abi.encodePacked(admin[msg.sender].RegisteredOrgID2))\n            ==\n            keccak256(abi.encodePacked(orgID))\n        );\n\n        bool isVoterRegisteredForOrg = (\n            keccak256(abi.encodePacked(voters[msg.sender].RegisteredOrgID1))\n            ==\n            keccak256(abi.encodePacked(orgID))\n        )||(\n            keccak256(abi.encodePacked(voters[msg.sender].RegisteredOrgID2))\n            ==\n            keccak256(abi.encodePacked(orgID))\n        );\n\n        require(\n            isAdminRegisteredForOrg || isVoterRegisteredForOrg,\n            // error 31a = Incorrect access control\n            \"error:31a\"\n        );\n        _;\n    }\n\n    modifier canCreateOrg() {\n        require(\n            block.number >= admin[msg.sender].nextOrgCreationBlock,\n            // error 32 = error Block await for 2nd Admin Org Registration\n            \"error:32\"\n        );\n        _;\n    }\n\n    modifier onlyVotreXOwner() {\n        require(\n            msg.sender == VotreXOwnerAddress,\n            // error 31b = errror Owner access\n            \"error:31b\"\n        );\n        _;\n    }\n\n    modifier onlyWhenActivated() {\n        require(\n            VotreXActivated == true,\n            // error 33 = error system still disabled\n            \"error:33\"\n        );\n        _;\n    }\n\n    function CheckTokenETHBalance () external view onlyVotreXOwner returns (uint256) {\n        return (address(this).balance);\n    }\n\n    function changeSystemState() external onlyVotreXOwner{\n        if (VotreXActivated == false) {\n            VotreXActivated = true;\n        } else {\n            VotreXActivated = false;\n        }\n    }\n\n    // function setOrgPriceFee(uint256 _PriceinEther) external onlyVotreXOwner {\n    //     OrganizationPriceFee = _PriceinEther * 1 ether;\n    // }\n\n    // receive() external payable {\n\n    // }\n\n    function registerOrganization(\n        string memory _orgName,\n        string memory _orgID,\n        string memory _adminName,\n        OrganizationType _orgType\n    )\n        external\n        canCreateOrg\n        onlyWhenActivated\n    {\n        ElectionAdmins storage AdminInfo = admin[msg.sender];\n\n        // require(\n        //     msg.value == OrganizationPriceFee,\n        //     // error 34 = error wrong ether value being sent\n        //     \"error:34\"\n        // );\n\n        require(\n            organizationsCounter < 32000,\n            // error 35 = error limit reached\n            \"error:35\"\n        );\n\n        require(\n            bytes32(organizationData[_orgID].orgName).length > 0,\n            // error 36a = error incorrect null value\n            \"error:36a\"\n        );\n\n        require(\n            organizationData[_orgID].electionAdminAddresses == address(0),\n            // error 36a = error incorrect null value\n            \"error:36a\"\n        );\n\n        require(\n            UtilityLibrary.onlyAlphanumericCharacters(_orgID),\n            // error36b = Only Alpha Numeric character allowed\n            \"error:36b\"\n        );\n\n        require(\n            bytes(_orgName).length > 0,\n            // error 36a = error incorrect null value\n            \"error:36a\"\n        );\n\n        require(\n            bytes(_orgName).length < 32,\n            // error 36c = error character length limit\n\n            \"error:36c\"\n        );\n\n        require(\n            bytes(_adminName).length > 1\n        );\n\n        require(\n            bytes(_orgID).length == 3\n            ||\n            bytes(_orgID).length == 4,\n            \"Org ID should 3 - 4 characters\"\n        );\n\n        require(\n            keccak256(abi.encodePacked(admin[msg.sender].RegisteredOrgID1))\n            !=\n            keccak256(abi.encodePacked(_orgID))\n            &&\n            keccak256(abi.encodePacked(admin[msg.sender].RegisteredOrgID2))\n            !=\n            keccak256(abi.encodePacked(_orgID)),\n            \"Admin is registered\"\n        );\n\n        Organization storage newOrg = organizationData[_orgID];\n        newOrg.orgID = _orgID;\n        newOrg.orgName = bytes32(abi.encodePacked(_orgName));\n        newOrg.orgType = _orgType;\n        newOrg.electionAdminAddresses = msg.sender;\n        newOrg.activeElectionCounter = 0;\n        newOrg.totalMembers = 1;\n\n        bytes10 UniqueAdminvoterID = bytes10(abi.encodePacked(_orgID, \"-\", \"Admin\"));\n\n        if (bytes(admin[msg.sender].RegisteredOrgID1).length == 0) {\n            admin[msg.sender].RegisteredOrgID1 = _orgID;\n            admin[msg.sender].AdminVoterIDOrg1 = UniqueAdminvoterID;\n        } else if (bytes(admin[msg.sender].RegisteredOrgID2).length == 0) {\n            admin[msg.sender].RegisteredOrgID2 = _orgID;\n            admin[msg.sender].AdminVoterIDOrg2 = UniqueAdminvoterID;\n        }\n\n        AdminInfo.electionAdminAddress = msg.sender;\n        AdminInfo.adminName = bytes32(abi.encodePacked(_adminName));\n        AdminInfo.isRegistered = true;\n        ++AdminInfo.adminOrgCount;\n\n        registeredAdmin[msg.sender] = true;\n        votersIDExists[UniqueAdminvoterID] = true;\n\n        AdminInfo.nextOrgCreationBlock = 50 + block.number;\n\n        ++organizationsCounter;\n        ++VotreXUserCounter;\n    }\n\n    \n\n    function registerVoter(\n        string memory _voterName,\n        string memory _orgID,\n        bytes32 uniqueVoterID\n    )\n        external\n        onlyWhenActivated\n    {\n        // require(\n        //     msg.value == (OrganizationPriceFee/2)\n        // );\n\n        Voter storage voter = voters[msg.sender];\n        // string memory uniqueVoterID = generateUniqueVoterID(_orgID);\n        bytes16 VoterID16 = bytes16(abi.encodePacked(uniqueVoterID));\n        // bytes32 orgIDs = keccak256(abi.encodePacked(_orgID));\n\n        require(\n            organizationData[_orgID].totalMembers < 5000,\n            \"Maximum member limit reached\"\n        );\n\n        require(\n            bytes(_voterName).length > 1,\n            \"Please fill Voter Name\"\n        );\n\n        require(\n            bytes(_voterName).length < 24,\n            \"Voter name limit is 24 characters\"\n        );\n\n        require(\n            keccak256(abi.encodePacked(voters[msg.sender].RegisteredOrgID1))\n            !=\n            keccak256(abi.encodePacked(_orgID))\n            &&\n            keccak256(abi.encodePacked(voters[msg.sender].RegisteredOrgID2))\n            !=\n            keccak256(abi.encodePacked(_orgID))\n            &&\n            !registeredAdmin[msg.sender],\n            \"Voter is registered in Org\"\n        );\n\n        require(\n            ElectionActiveCheck(_orgID) < 1,\n            \"Election in progress!\"\n        );\n\n        require(\n            bytes16(uniqueVoterID).length > 0\n        );\n\n        require(\n            bytes(organizationData[_orgID].orgID).length != 0,\n            \"Organization does not exist\"\n        );\n\n        if (bytes(voter.RegisteredOrgID1).length == 0) {\n            voter.RegisteredOrgID1 = _orgID;\n            voter.VoterIDOrg1 = VoterID16;\n        } else if (bytes(voter.RegisteredOrgID2).length == 0) {\n            voter.RegisteredOrgID2 = _orgID;\n            voter.VoterIDOrg2 = VoterID16;\n        }\n\n        voter.VoterAddress = msg.sender;\n        voter.VoterName = _voterName;\n        voter.participatedElectionEvents = new string[](0);\n        voter.isRegistered = true;\n        votersIDExists[VoterID16] = true;\n        ++VotreXUserCounter;\n        ++organizationData[_orgID].totalMembers;\n    }\n\n    function createElection(\n        string memory _orgID,\n        string memory _userElectionID,\n        string memory _electionName\n    )\n        external\n        onlyWhenActivated\n        onlyOrgAdmin(_orgID)\n    {\n        require(\n            bytes(organizationData[_orgID].orgID).length > 0\n        );\n\n        require(\n            bytes(_userElectionID).length > 1,\n            // error 36a = error incorrect null value\n            \"error 36a\"\n        \n        );\n\n        require(\n            bytes(_userElectionID).length < 5,\n            \"ID should < 5 characters\"\n        );\n\n        require(\n            bytes(_electionName).length > 1\n        );\n\n        require(\n            bytes(_electionName).length < 25,\n            \"Election name should < 25\"\n        );\n\n        require(\n            organizationData[_orgID].activeElectionCounter < 10,\n            \"Maximum events reached\"\n        );\n\n        bytes32 generatedElectionID = bytes32(abi.encodePacked(_orgID, \"-\", _userElectionID));\n        ElectionDetail storage newElection = electionInfo[generatedElectionID];\n\n        require(\n            !electionExistanceChecks[generatedElectionID],\n            \"Election ID exists\"\n        );\n\n        newElection.orgID = _orgID;\n        newElection.electionID = generatedElectionID;\n        newElection.electionName = bytes32(abi.encodePacked(_electionName));\n        newElection.candidateList = 0;\n        newElection.status = ElectionStatus.Preparation;\n        electionExistanceChecks[generatedElectionID] = true;\n        organizationData[_orgID].electionIDs.push(generatedElectionID);\n        organizationData[_orgID].ElectionName.push(bytes32(abi.encodePacked(_electionName)));\n        organizationData[_orgID].electionStatus.push(ElectionStatus.Preparation);\n        ++organizationData[_orgID].onPreparationElectionCounter;\n    }\n\n    function startElection(string memory _userElectionID) external onlyOrgAdmin(_userElectionID){\n        // error 36a = error incorrect null value\n        require(bytes(_userElectionID).length > 0, \"error:36a\");\n\n        bytes32 userElectionID = bytes32(abi.encodePacked(_userElectionID));\n        string memory orgIDs = UtilityLibrary.extractOrgId(_userElectionID);\n\n        ElectionDetail storage election = electionInfo[userElectionID];\n        require(bytes16(election.electionID).length > 0, \"Invalid election ID\");\n        require(election.status == ElectionStatus.Preparation, \"Election is not in preparation\");\n\n        election.startTime = 5 + block.timestamp;\n        election.status = ElectionStatus.Started;\n        ++election.waveNumber;\n        ++organizationData[orgIDs].activeElectionCounter;\n        --organizationData[orgIDs].onPreparationElectionCounter;\n        uint256 index = findElectionIndex(organizationData[orgIDs].electionIDs, userElectionID);\n        require(index < organizationData[orgIDs].electionIDs.length, \"Election not found\");\n        organizationData[orgIDs].electionStatus[index] = ElectionStatus.Started;\n    }\n\n    function findElectionIndex(bytes32[] storage array, bytes32 electionID) internal view returns (uint256) {\n        for (uint256 i = 0; i < array.length; i++) {\n            if (array[i] == electionID) {\n                return i;\n            }\n        }\n        revert(\"Election ID not found\");\n    }\n\n    function finishElection(\n        string memory _userElectionID,\n        bytes32 _dataHash,\n        bool isSingleWaveOrFinalStage,\n        uint256 threshold\n    ) external onlyOrgAdmin(_userElectionID) {\n        bytes32 packedElectionID = bytes32(abi.encodePacked(_userElectionID));\n        string memory orgIDs = UtilityLibrary.extractOrgId(_userElectionID);\n        bytes32 electionIdBytes = keccak256(abi.encodePacked(_userElectionID));\n        ElectionDetail storage elections = electionInfo[packedElectionID];\n        string memory adminName = getAdminName(msg.sender);\n\n        require(\n            bytes(_userElectionID).length > 0,\n            \"Invalid election ID\"\n        );\n\n        require(_dataHash.length > 0, \"Invalid data hash\");\n\n        require(\n            elections.totalParticipants > calculateValidElection(_userElectionID),\n            \"need 50% total member to finish\"\n        );\n\n        require(!elections.isFinished, \"Election finished\");\n        \n        require(\n            elections.status == ElectionStatus.Started,\n            \"Election is not started\"\n        );\n\n        if (isSingleWaveOrFinalStage == true)\n        {\n            // Kondisi jika hanya 2 kandidat tersisa\n            require(elections.candidates.length == 2, \"Single-wave requires exactly 2 candidates\");\n            string memory electionWinner = determineWinner(_userElectionID);\n            elections.endTime = 10 + block.timestamp;\n            elections.status = ElectionStatus.Finished;\n            elections.isFinished = true;\n\n            ElectionResult storage newelectionResult = electionResults[_userElectionID];\n            newelectionResult.isPruned = true;\n            newelectionResult.totalVoter = elections.totalParticipants;\n            newelectionResult.adminAddress = msg.sender;\n            newelectionResult.startTime = elections.startTime;\n            newelectionResult.endTime = elections.endTime;\n            newelectionResult.digitalSignature = _dataHash;\n            newelectionResult.registeredOrganization = elections.orgID;\n            newelectionResult.electionID = packedElectionID;\n            newelectionResult.waveNumber = elections.waveNumber;\n            newelectionResult.electionName = elections.electionName;\n            newelectionResult.electionWinner = electionWinner;\n            newelectionResult.signedBy = adminName;\n\n            for (uint i = 0; i < elections.candidates.length; i++) {\n                CandidateDetail memory candidate = elections.candidates[i];\n                newelectionResult.candidates.push(\n                    CandidateDetail({\n                        candidateID: candidate.candidateID,\n                        candidateName: candidate.candidateName,\n                        candidateVoteCount: candidate.candidateVoteCount\n                    })\n                );\n            }\n            \n            delete electionInfo[packedElectionID];\n            uint256 index = findElectionIndex(organizationData[orgIDs].electionIDs, packedElectionID);\n            organizationData[orgIDs].electionStatus[index] = ElectionStatus.Finished;\n            ++organizationData[orgIDs].archivedElectionCounter;\n            --organizationData[orgIDs].activeElectionCounter;\n        } else {\n            // Kondisi jika kandidat lebih dari 2, reset kandidat\n            require(elections.candidates.length > 2, \"More than 2 candidates required\");\n\n            for (uint256 i = 0; i < elections.candidates.length; ) {\n                if (elections.candidates[i].candidateVoteCount < threshold) {\n                    elections.candidates[i] = elections.candidates[elections.candidates.length - 1];\n                    elections.candidates.pop(); // Hapus kandidat terakhir\n                    elections.totalParticipants = 0;\n                } else {\n                    ++i;\n                }\n            }\n\n            // Reset suara kandidat yang tersisa\n            for (uint256 i = 0; i < elections.candidates.length; i++) {\n                elections.candidates[i].candidateVoteCount = 0;\n            }\n\n            // Reset status hasVoted untuk semua peserta\n            address[] storage voter = votersList[electionIdBytes];\n            require(voter.length > 0, \"No voters to reset\");\n\n            for (uint256 i = 0; i < voter.length; i++) {\n                hasVoted[electionIdBytes][voter[i]] = false;\n            }\n\n            // Debugging log untuk memastikan reset berjalan\n            for (uint256 i = 0; i < voter.length; i++) {\n                bool status = hasVoted[electionIdBytes][voter[i]];\n                emit LogResetVoter(voter[i], status); // Emit event untuk debugging\n            }\n\n            // Hapus daftar voters untuk tahap berikutnya\n            delete votersList[electionIdBytes];\n            ++elections.waveNumber;\n            elections.isFinished = false;\n\n            emit ElectionReset(_userElectionID);\n        }\n\n    }\n\n    // Event untuk menginformasikan frontend tentang reset pemilihan\n    event ElectionReset(string electionID);\n    event LogResetVoter(address voter, bool status);\n\n\n    function calculateValidElection(string memory _userElectionID)\n        private\n        view\n        returns (uint256)\n    {\n        string memory orgID = UtilityLibrary.extractOrgId(_userElectionID);\n        Organization storage OrgData = organizationData[orgID];\n        uint256 MIN_VOTES_PERCENTAGE = 1 + (OrgData.totalMembers / 2);\n\n        return MIN_VOTES_PERCENTAGE;\n    }\n\n\n    function getOwnerAddress() external view returns (address) {\n        return VotreXOwnerAddress;\n    }\n\n    function getOwnerName() external view returns (bytes32) {\n        return VotreXOwnerName;\n    }\n\n    function getTotalUser() external view returns (uint256) {\n        return VotreXUserCounter;\n    }\n\n    function getElectionListInOrg(string memory orgID)\n        public\n        view\n        returns (bytes32[] memory, bytes32[] memory, ElectionStatus[] memory)\n    {\n        Organization storage org = organizationData[orgID];\n        return (org.electionIDs, org.ElectionName, org.electionStatus);\n    }\n\n    function getAdminName(address adminAddress) private view returns (string memory) {\n        return string(abi.encodePacked(admin[adminAddress].adminName));\n    }\n\n\n    function vote(\n        string memory _userElectionID,\n        string memory _candidateName\n    )\n        external\n        onlyWhenActivated\n        onlyAuthorizedMember(_userElectionID)\n    {\n        bytes32 userElectionID = bytes32(abi.encodePacked(_userElectionID));\n        ElectionDetail storage election = electionInfo[userElectionID];\n        uint8 candidateIDs = uint8(election.candidates.length);\n        bytes32 electionIdBytes = keccak256(abi.encodePacked(_userElectionID));\n\n        // Pastikan nama kandidat tidak kosong\n        require(bytes(_candidateName).length > 0, \"Candidate name cannot be empty!\");\n        require(!hasVoted[electionIdBytes][msg.sender], \"Anda sudah memilih!\");\n        require(election.status == ElectionStatus.Started, \"Election is not in progress\");\n\n\n        bool candidateExists = false;\n\n        // Loop melalui array kandidat untuk mencari nama yang cocok\n        for (uint256 i = 0; i < election.candidates.length; i++) {\n            if (\n                keccak256(abi.encodePacked(election.candidates[i].candidateName))\n                ==\n                keccak256(abi.encodePacked(_candidateName))) {\n                // Jika kandidat ditemukan, tambahkan voteCount\n                election.candidates[i].candidateVoteCount += 1;\n                candidateExists = true;\n                break;\n                }\n        }\n\n        // Jika kandidat belum ada, tambahkan kandidat baru ke array\n        if (!candidateExists) {\n            CandidateDetail memory newCandidate = CandidateDetail({\n                candidateID: candidateIDs,\n                candidateName: _candidateName,\n                candidateVoteCount: 1\n            });\n            election.candidates.push(newCandidate);\n        }\n        hasVoted[electionIdBytes][msg.sender] = true;\n        votersList[electionIdBytes].push(msg.sender);\n        ++election.totalParticipants;\n    }\n\n    function getAllCandidates(string memory _userElectionID) public view returns (CandidateDetail[] memory) {\n        \n        bytes32 userElectionID = bytes32(abi.encodePacked(_userElectionID));\n        // Ambil detail pemilu berdasarkan ID\n        ElectionDetail storage election = electionInfo[userElectionID];\n\n        // Pastikan ada kandidat dalam pemilu\n        require(election.candidates.length > 0, \"No candidates found in this election!\");\n\n        // Kembalikan array kandidat dari pemilu\n        return election.candidates;\n    }\n\n    function isVotreXActivated() external onlyVotreXOwner view returns (bool) {\n        return VotreXActivated;\n    }\n\n    function getTotalOrganization() external virtual view returns (uint256) {\n        return organizationsCounter;\n    }\n\n    function getElectionInfo(string memory _userElectionID)\n        external\n        view\n        returns(\n            bytes32 electionID,\n            string memory electionName,\n            uint256 waveNumber,\n            uint256 totalCandidates,\n            uint8[] memory candidateIDs, // Added\n            string[] memory candidateNames,\n            uint256[] memory voteCounts,\n            uint256 totalParticipants,\n            ElectionStatus statusElection\n        )\n    {\n        bytes32 userElectionID = bytes32(abi.encodePacked(_userElectionID));\n\n        ElectionDetail storage election = electionInfo[userElectionID];\n        require(\n            bytes32(election.electionID).length > 0\n        );\n\n        electionID = election.electionID;\n        electionName = string(abi.encodePacked(election.electionName));\n        waveNumber = election.waveNumber;\n        totalCandidates = election.candidates.length;\n        candidateIDs = new uint8[](totalCandidates); // Initialized\n        candidateNames = new string[](totalCandidates);\n        voteCounts = new uint256[](totalCandidates);\n        totalParticipants = election.totalParticipants;\n        statusElection = electionInfo[userElectionID].status;\n\n        for (uint256 i = 0; i < totalCandidates; ++i) {\n            candidateIDs[i] = election.candidates[i].candidateID; // Added\n            candidateNames[i] = election.candidates[i].candidateName;\n            voteCounts[i] = election.candidates[i].candidateVoteCount;\n        }\n\n        return (\n            electionID,\n            electionName,\n            waveNumber,\n            totalCandidates,\n            candidateIDs,\n            candidateNames,\n            voteCounts,\n            totalParticipants,\n            statusElection\n        );\n    }\n\n    function getCandidateResult(string memory _electionID) \n        public \n        view \n        returns (\n            uint8[] memory candidateID,\n            string[] memory candidateName,\n            uint256[] memory candidateVoteCount\n        ) \n    {\n\n        uint totalCandidates = electionResults[_electionID].candidates.length;\n\n        uint8[] memory candidateIDs = new uint8[](totalCandidates);\n        string[] memory candidateNames = new string[](totalCandidates);\n        uint256[] memory candidateVoteCounts = new uint256[](totalCandidates);\n\n        for (uint i = 0; i < totalCandidates; i++) {\n            candidateIDs[i] = electionResults[_electionID].candidates[i].candidateID;\n            candidateNames[i] = electionResults[_electionID].candidates[i].candidateName;\n            candidateVoteCounts[i] = electionResults[_electionID].candidates[i].candidateVoteCount;\n        }\n\n        return (\n            candidateIDs,\n            candidateNames,\n            candidateVoteCounts\n        );\n    }\n\n    function getUserInfo() external view returns (\n        bool isRegistered,\n        bool isAdmin,\n        address userAddress,\n        string memory userName,\n        string[] memory registeredOrgList,\n        string[] memory voterIDList,\n        string[] memory participatedElectionEvents\n    ) {\n        userAddress = msg.sender;\n\n        if (admin[userAddress].isRegistered) {\n            ElectionAdmins storage adminInfo = admin[userAddress];\n            \n            string[] memory VoterRegisteredOrgList = new string[](2);\n            VoterRegisteredOrgList[0] = adminInfo.RegisteredOrgID1;\n            VoterRegisteredOrgList[1] = adminInfo.RegisteredOrgID2;\n\n            string[] memory VoterIDList = new string[](2);\n            VoterIDList[0] = string(abi.encodePacked(adminInfo.AdminVoterIDOrg1));\n            VoterIDList[1] = string(abi.encodePacked(adminInfo.AdminVoterIDOrg2));\n\n            return (\n                true,\n                true,\n                userAddress,\n                string(abi.encodePacked(adminInfo.adminName)),\n                VoterRegisteredOrgList,\n                VoterIDList,\n                new string[](0)\n            );\n\n        } else if (voters[userAddress].isRegistered) {\n            Voter storage voter = voters[userAddress];\n\n            string[] memory RegisteredOrgIDList = new string[](2);\n            RegisteredOrgIDList[0] = voter.RegisteredOrgID1;\n            RegisteredOrgIDList[1] = voter.RegisteredOrgID2;\n\n            string[] memory RegisteredVoterIDList = new string[](2);\n            RegisteredVoterIDList[0] = string(abi.encodePacked(voter.VoterIDOrg1));\n            RegisteredVoterIDList[1] = string(abi.encodePacked(voter.VoterIDOrg2));\n            return (\n                true,\n                false,\n                userAddress,\n                voter.VoterName,\n                RegisteredOrgIDList,\n                RegisteredVoterIDList,\n                voter.participatedElectionEvents\n            );\n        } else {\n            return (\n                false,\n                false,\n                userAddress,\n                \"\",\n                new string[](0),\n                new string[](0),\n                new string[](0)\n            );\n        }\n    }\n\n    function ElectionActiveCheck(string memory _orgID) private view returns (uint256) {\n\n        return organizationData[_orgID].activeElectionCounter;\n    \n    }\n\n    function hasParticipatedInElection(\n        address voterAddress,\n        bytes32 electionName\n    )\n        private\n        view\n        returns (bool)\n    {\n        Voter storage voter = voters[voterAddress];\n        for (uint i = 0; i < voter.participatedElectionEvents.length; ++i) {\n            if (\n                keccak256(abi.encodePacked(voter.participatedElectionEvents[i]))\n                ==\n                keccak256(abi.encodePacked(electionName))\n            ) {\n                return true; \n            }\n        }\n\n        return false; \n    }\n\n    function determineWinner(string memory _userElectionID) private view returns (string memory) {\n        bytes32 userElectionID = bytes32(abi.encodePacked(_userElectionID));\n        ElectionDetail storage election = electionInfo[userElectionID];\n        string memory winner = \"\";\n        uint256 maxVotes = 0;\n        for (uint8 i = 0; i < election.candidates.length; ++i) {\n            if (election.candidates[i].candidateVoteCount > maxVotes) {\n                maxVotes = election.candidates[i].candidateVoteCount;\n                winner = election.candidates[i].candidateName;\n            }\n        }\n\n        return winner;\n    }\n    \n    // function generateUniqueVoterID(string memory _orgID) public view returns (string memory) {\n    //     uint256 CurrentID = organizationData[_orgID].totalMembers;\n    //     uint256 nextID = ++CurrentID;\n\n    //     return string(abi.encodePacked(_orgID, \"-\", UtilityLibrary.uint2str(nextID)));\n    // }\n\n    function getOrgIDHash(string memory _orgID) external pure returns (bytes32) {\n        bytes32 orgIDHash = keccak256(abi.encodePacked(_orgID));\n\n        return (orgIDHash);\n    }\n    \n}\n"
    },
    "contracts/UtilityLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.7.0;\n\nlibrary UtilityLibrary {\n\tfunction calculateAge(\n\t\tbytes32 encryptedDate,\n\t\tint256 timeOffset\n\t) internal view returns (int256) {\n\t\tuint256 SECONDS_PER_YEAR = 31556952;\n\t\t// Step 1: convert encryptedDate (bytes32)  int256\n\t\tint256 rawEpoch = int256(uint256(encryptedDate)); // unwrap from bytes32\n\n\t\t// Step 2: remove offset to get real epoch time\n\t\tint256 birthEpoch = rawEpoch - timeOffset;\n\n\t\t// Step 3: now use current time (block.timestamp) which is uint256  cast to int256\n\t\tint256 nowEpoch = int256(block.timestamp);\n\n\t\t// Step 4: handle negative (invalid future date)\n\t\tif (birthEpoch > nowEpoch) return -1;\n\n\t\tint256 age = (nowEpoch - birthEpoch) / int256(SECONDS_PER_YEAR);\n\t\treturn age;\n\t}\n\n\tfunction isOver60Years(\n\t\tbytes32 birthDate,\n\t\tint256 timeOffset\n\t) internal view returns (bool) {\n\t\tint256 age = calculateAge(birthDate, timeOffset);\n\t\treturn age >= 60;\n\t}\n\n\tfunction extractOrgId(\n\t\tstring memory _userElectionID\n\t) internal pure returns (string memory) {\n\t\tstring[] memory parts = UtilityLibrary.splitString(\n\t\t\t_userElectionID,\n\t\t\t\"-\"\n\t\t);\n\t\trequire(parts.length > 0, \"Invalid custom election ID format\");\n\n\t\treturn parts[0];\n\t}\n\n\tfunction decodeBytes10(bytes10 data) internal pure returns (string memory) {\n\t\tstring memory decodedString = new string(10);\n\n\t\tassembly {\n\t\t\tmstore(add(decodedString, 32), data)\n\t\t}\n\n\t\treturn decodedString;\n\t}\n\n\tfunction capitalizeFirstLetter(\n\t\tstring memory str\n\t) internal pure returns (string memory) {\n\t\tbytes memory bStr = bytes(str);\n\t\tif (bStr.length == 0) return \"\"; // Return empty string if no input\n\n\t\t//  Convert first letter to uppercase\n\t\tif (bStr[0] >= 0x61 && bStr[0] <= 0x7A) {\n\t\t\t// Check if lowercase a-z\n\t\t\tbStr[0] = bytes1(uint8(bStr[0]) - 32);\n\t\t}\n\n\t\t//  Convert the rest to lowercase\n\t\tfor (uint256 i = 1; i < bStr.length; i++) {\n\t\t\tif (bStr[i] >= 0x41 && bStr[i] <= 0x5A) {\n\t\t\t\t// Check if uppercase A-Z\n\t\t\t\tbStr[i] = bytes1(uint8(bStr[i]) + 32); // Convert to lowercase\n\t\t\t}\n\t\t}\n\n\t\treturn string(bStr);\n\t}\n\n\tfunction arrayContains(\n\t\tstring[] storage array,\n\t\tstring memory element\n\t) internal view returns (bool) {\n\t\tfor (uint256 i = 0; i < array.length; ++i) {\n\t\t\tif (\n\t\t\t\tkeccak256(abi.encodePacked(array[i])) ==\n\t\t\t\tkeccak256(abi.encodePacked(element))\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction onlyAlphanumericCharacters(\n\t\tstring memory _input\n\t) internal pure returns (bool) {\n\t\tbytes memory b = bytes(_input);\n\t\tfor (uint i = 0; i < b.length; ++i) {\n\t\t\tif (\n\t\t\t\t!((uint8(b[i]) >= 48 && uint8(b[i]) <= 57) || // 0-9\n\t\t\t\t\t(uint8(b[i]) >= 65 && uint8(b[i]) <= 90) || // A-Z\n\t\t\t\t\t(uint8(b[i]) >= 97 && uint8(b[i]) <= 122)) // a-z\n\t\t\t) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction allowWhiteSpace(\n\t\tstring memory _input\n\t) internal pure returns (bool) {\n\t\tbytes memory b = bytes(_input);\n\t\tfor (uint i = 0; i < b.length; ++i) {\n\t\t\tif (\n\t\t\t\t!((uint8(b[i]) >= 48 && uint8(b[i]) <= 57) || // 0-9\n\t\t\t\t\t(uint8(b[i]) >= 65 && uint8(b[i]) <= 90) || // A-Z\n\t\t\t\t\t(uint8(b[i]) >= 97 && uint8(b[i]) <= 122)) || // a-z\n\t\t\t\tuint8(b[i]) == 32 // Space\n\t\t\t) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction appendToStringArray(\n\t\tstring[] memory array,\n\t\tstring memory newValue\n\t) internal pure returns (string[] memory) {\n\t\tstring[] memory newArray = new string[](array.length + 1);\n\n\t\tfor (uint32 i = 0; i < array.length; ++i) {\n\t\t\tnewArray[i] = array[i];\n\t\t}\n\n\t\tnewArray[array.length] = newValue;\n\n\t\treturn newArray;\n\t}\n\n\tfunction uintToString(uint48 value) internal pure returns (string memory) {\n\t\tif (value == 0) {\n\t\t\treturn \"0\";\n\t\t}\n\n\t\tuint48 temp = value;\n\t\tuint48 length;\n\t\twhile (temp != 0) {\n\t\t\tlength++;\n\t\t\ttemp /= 10;\n\t\t}\n\n\t\tbytes memory buffer = new bytes(length);\n\t\tuint48 i = length - 1;\n\t\twhile (value != 0) {\n\t\t\tbuffer[i] = bytes1(uint8(48 + (value % 10)));\n\t\t\tvalue /= 10;\n\t\t\ti--;\n\t\t}\n\n\t\treturn string(buffer);\n\t}\n\n\tfunction uint2str(\n\t\tuint _i\n\t) internal pure returns (string memory _uintAsString) {\n\t\tif (_i == 0) {\n\t\t\treturn \"0\";\n\t\t}\n\t\tuint j = _i;\n\t\tuint len;\n\t\twhile (j != 0) {\n\t\t\t++len;\n\t\t\tj /= 10;\n\t\t}\n\t\tbytes memory bstr = new bytes(len);\n\t\tuint k = len;\n\t\twhile (_i != 0) {\n\t\t\tk = k - 1;\n\t\t\tuint8 temp = (48 + uint8(_i - (_i / 10) * 10));\n\t\t\tbytes1 b1 = bytes1(temp);\n\t\t\tbstr[k] = b1;\n\t\t\t_i /= 10;\n\t\t}\n\t\treturn string(bstr);\n\t}\n\n\tfunction compareStrings(\n\t\tstring memory a,\n\t\tstring memory b\n\t) internal pure returns (bool) {\n\t\treturn (keccak256(abi.encodePacked(a)) ==\n\t\t\tkeccak256(abi.encodePacked(b)));\n\t}\n\n\tfunction splitString(\n\t\tstring memory str,\n\t\tstring memory delimiter\n\t) internal pure returns (string[] memory) {\n\t\tbytes memory strBytes = bytes(str);\n\t\tbytes memory delimiterBytes = bytes(delimiter);\n\n\t\tuint delimiterCount = 1;\n\t\tfor (uint i = 0; i < strBytes.length; ++i) {\n\t\t\tif (strBytes[i] == delimiterBytes[0]) {\n\t\t\t\t++delimiterCount;\n\t\t\t}\n\t\t}\n\n\t\tstring[] memory parts = new string[](delimiterCount);\n\n\t\tuint partStart = 0;\n\t\tuint partIndex = 0;\n\t\tfor (uint i = 0; i < strBytes.length; ++i) {\n\t\t\tif (strBytes[i] == delimiterBytes[0]) {\n\t\t\t\tparts[partIndex] = substring(str, partStart, i);\n\t\t\t\tpartStart = i + 1;\n\t\t\t\tpartIndex++;\n\t\t\t}\n\t\t}\n\n\t\t// Add the last part\n\t\tparts[partIndex] = substring(str, partStart, strBytes.length);\n\n\t\treturn parts;\n\t}\n\n\tfunction substring(\n\t\tstring memory str,\n\t\tuint startIndex,\n\t\tuint endIndex\n\t) internal pure returns (string memory) {\n\t\tbytes memory strBytes = bytes(str);\n\t\trequire(\n\t\t\tstartIndex <= endIndex && endIndex <= strBytes.length,\n\t\t\t\"Invalid substring indices\"\n\t\t);\n\n\t\tbytes memory result = new bytes(endIndex - startIndex);\n\t\tfor (uint i = startIndex; i < endIndex; ++i) {\n\t\t\tresult[i - startIndex] = strBytes[i];\n\t\t}\n\n\t\treturn string(result);\n\t}\n\n\tfunction extractOrgIdFromElectionId(\n\t\tstring memory _userElectionID\n\t) internal pure returns (string memory) {\n\t\tbytes memory orgIdBytes = bytes(_userElectionID);\n\n\t\t// Split the input string at the hyphen ('-')\n\t\tuint8 i = 0;\n\t\twhile (i < orgIdBytes.length && orgIdBytes[i] != \"-\") {\n\t\t\t// ASCII code for hyphen '-'\n\t\t\t++i;\n\t\t}\n\n\t\t// If a hyphen is found, extract the organization ID\n\t\tif (i < orgIdBytes.length) {\n\t\t\tbytes memory extractedBytes = new bytes(i);\n\t\t\tfor (uint8 j = 0; j < i; ++j) {\n\t\t\t\textractedBytes[j] = orgIdBytes[j];\n\t\t\t}\n\t\t\treturn string(extractedBytes);\n\t\t}\n\n\t\treturn \"\";\n\t}\n\n\tfunction concat(\n\t\tstring memory _a,\n\t\tstring memory _b\n\t) internal pure returns (string memory) {\n\t\treturn string(abi.encodePacked(bytes(_a), bytes(_b)));\n\t}\n}\n"
    },
    "contracts/VotreXSystemRC2C.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// pragma abicoder v2;\npragma solidity ^0.8.24;\n\nimport \"./UtilityLibrary.sol\";\n\ncontract TestCompleXA2C {\n\tusing UtilityLibrary for *;\n\n\tconstructor(uint256 _timeOffset) {\n\t\tVotreXOwnerAddress = msg.sender;\n\t\tVotreXActivated = true;\n\t\tTime_Offset = _timeOffset;\n\t}\n\n\tuint256 private organizationsCounter;\n\tbool private VotreXActivated;\n\taddress private VotreXOwnerAddress;\n\tbytes32 public VotreXOwnerName = keccak256(abi.encodePacked(\"ATom\"));\n\tuint256 private VotreXUserCounter;\n\tuint256 private immutable Time_Offset;\n\n\tmapping(string => Organization) public organizationData;\n\tmapping(address => ElectionAdmins) public admin;\n\tmapping(address => Voter) public voters;\n\tmapping(bytes32 => address[]) private voterAddrList;\n\tmapping(bytes32 => string[]) private voterNameList;\n\tmapping(string => bytes32) private voterBirthDateByName;\n\tmapping(bytes32 => mapping(address => bool)) public hasVoted;\n\tmapping(bytes32 => mapping(string => CandidateDetail))\n\t\tpublic temporalCandidates;\n\tmapping(bytes32 => ElectionDetail) public electionInfo;\n\tmapping(string => ElectionResult) public electionResults;\n\tmapping(bytes32 => bool) private electionExistanceChecks;\n\tmapping(bytes16 => bool) private votersIDExists;\n\tmapping(address => bool) private registeredAdmin;\n\n\tenum ElectionStatus {\n\t\tPreparation,\n\t\tStarted,\n\t\tHeadToHeadWave,\n\t\tFinished,\n\t\tFailed\n\t}\n\n\tenum OrganizationType {\n\t\tOrganization,\n\t\tChurches,\n\t\tCorporate\n\t}\n\n\tstruct Organization {\n\t\tOrganizationType orgType;\n\t\taddress electionAdminAddresses;\n\t\tuint256 onPreparationElectionCounter;\n\t\tuint256 activeElectionCounter;\n\t\tuint256 archivedElectionCounter;\n\t\tuint256 totalMembers;\n\t\tbytes32 orgName;\n\t\tstring orgID;\n\t\tbytes32[] electionIDs;\n\t\tbytes32[] ElectionName;\n\t\tElectionStatus[] electionStatus;\n\t}\n\n\tstruct ElectionAdmins {\n\t\tbool isRegistered;\n\t\tuint8 adminOrgCount;\n\t\tbytes10 AdminVoterIDOrg1;\n\t\tbytes10 AdminVoterIDOrg2;\n\t\taddress electionAdminAddress;\n\t\tuint256 nextOrgCreationBlock;\n\t\tbytes32 adminName;\n\t\tbytes32 userBirthDate;\n\t\tstring RegisteredOrgID1;\n\t\tstring RegisteredOrgID2;\n\t}\n\n\tstruct ElectionResult {\n\t\tbool isPruned;\n\t\taddress adminAddress;\n\t\tuint256 waveNumber;\n\t\tuint startTime;\n\t\tuint endTime;\n\t\tuint totalVoter;\n\t\tbytes32 electionID;\n\t\tbytes32 electionName;\n\t\tbytes32 digitalSignature;\n\t\tstring registeredOrganization;\n\t\tstring electionWinner;\n\t\tstring signedBy;\n\t\tCandidateDetail[] candidates;\n\t}\n\n\tstruct Voter {\n\t\tbool isRegistered;\n\t\taddress VoterAddress;\n\t\tbytes16 VoterIDOrg1;\n\t\tbytes16 VoterIDOrg2;\n\t\tstring VoterName;\n\t\tstring RegisteredOrgID1;\n\t\tstring RegisteredOrgID2;\n\t\tbytes32 userBirthDate;\n\t}\n\n\tstruct ElectionDetail {\n\t\tElectionStatus status;\n\t\tuint8 candidateList;\n\t\tbool isFinished;\n\t\tbool isHaveCandidateMode;\n\t\tbytes32 electionID;\n\t\tbytes32 electionName;\n\t\tuint startTime;\n\t\tuint endTime;\n\t\tstring orgID;\n\t\tuint256 totalParticipants;\n\t\tuint256 waveNumber;\n\t\tCandidateDetail[] candidates;\n\t\tbool isTiedVoting;\n\t}\n\n\tstruct CandidateDetail {\n\t\tuint8 candidateID;\n\t\tuint256 candidateVoteCount;\n\t\tstring candidateName;\n\t}\n\n\tmodifier onlyOrgAdmin(string memory _IDParameters) {\n\t\tbool isAdminRegisteredForOrg = false;\n\t\tif (\n\t\t\tkeccak256(abi.encodePacked(admin[msg.sender].RegisteredOrgID1)) ==\n\t\t\tkeccak256(abi.encodePacked(_IDParameters)) ||\n\t\t\tkeccak256(abi.encodePacked(admin[msg.sender].RegisteredOrgID2)) ==\n\t\t\tkeccak256(abi.encodePacked(_IDParameters))\n\t\t) {\n\t\t\tisAdminRegisteredForOrg = true;\n\t\t} else if (\n\t\t\tbytes32(abi.encodePacked(admin[msg.sender].RegisteredOrgID1)) !=\n\t\t\tbytes32(abi.encodePacked(_IDParameters)) ||\n\t\t\tbytes32(abi.encodePacked(admin[msg.sender].RegisteredOrgID2)) !=\n\t\t\tbytes32(abi.encodePacked(_IDParameters))\n\t\t) {\n\t\t\tstring memory orgID = UtilityLibrary.extractOrgId(_IDParameters);\n\t\t\tisAdminRegisteredForOrg = true;\n\t\t}\n\n\t\trequire(isAdminRegisteredForOrg, \"error:31a\");\n\t\t_;\n\t}\n\n\tmodifier onlyAuthorizedMember(string memory _userElectionID) {\n\t\tstring memory orgID = UtilityLibrary.extractOrgId(_userElectionID);\n\n\t\tbool isAdminRegisteredForOrg = (keccak256(\n\t\t\tabi.encodePacked(admin[msg.sender].RegisteredOrgID1)\n\t\t) == keccak256(abi.encodePacked(orgID))) ||\n\t\t\t(keccak256(abi.encodePacked(admin[msg.sender].RegisteredOrgID2)) ==\n\t\t\t\tkeccak256(abi.encodePacked(orgID)));\n\n\t\tbool isVoterRegisteredForOrg = (keccak256(\n\t\t\tabi.encodePacked(voters[msg.sender].RegisteredOrgID1)\n\t\t) == keccak256(abi.encodePacked(orgID))) ||\n\t\t\t(keccak256(abi.encodePacked(voters[msg.sender].RegisteredOrgID2)) ==\n\t\t\t\tkeccak256(abi.encodePacked(orgID)));\n\n\t\trequire(\n\t\t\tisAdminRegisteredForOrg || isVoterRegisteredForOrg,\n\t\t\t// error 31a = Incorrect access control\n\t\t\t\"error:31a\"\n\t\t);\n\t\t_;\n\t}\n\n\tmodifier canCreateOrg() {\n\t\trequire(\n\t\t\tblock.number >= admin[msg.sender].nextOrgCreationBlock,\n\t\t\t// error 32 = error Block await for 2nd Admin Org Registration\n\t\t\t\"error:32\"\n\t\t);\n\t\t_;\n\t}\n\n\tmodifier onlyVotreXOwner() {\n\t\trequire(\n\t\t\tmsg.sender == VotreXOwnerAddress,\n\t\t\t// error 31b = errror Owner access\n\t\t\t\"error:31b\"\n\t\t);\n\t\t_;\n\t}\n\n\tmodifier onlyWhenActivated() {\n\t\trequire(\n\t\t\tVotreXActivated == true,\n\t\t\t// error 33 = error system still disabled\n\t\t\t\"error:33\"\n\t\t);\n\t\t_;\n\t}\n\n\tfunction changeSystemState() external onlyVotreXOwner {\n\t\tif (VotreXActivated == false) {\n\t\t\tVotreXActivated = true;\n\t\t} else {\n\t\t\tVotreXActivated = false;\n\t\t}\n\t}\n\n\tfunction registerOrganization(\n\t\tstring memory _orgName,\n\t\tstring memory _orgID,\n\t\tstring memory _adminName,\n\t\tbytes32 _userBirthDate,\n\t\tOrganizationType _orgType\n\t) external canCreateOrg onlyWhenActivated {\n\t\tElectionAdmins storage AdminInfo = admin[msg.sender];\n\t\trequire(\n\t\t\torganizationsCounter < 32000,\n\t\t\t// error 35 = error limit reached\n\t\t\t\"error:35\"\n\t\t);\n\n\t\trequire(\n\t\t\tbytes32(organizationData[_orgID].orgName).length > 0,\n\t\t\t// error 36a = error incorrect null value\n\t\t\t\"error:36a\"\n\t\t);\n\n\t\trequire(\n\t\t\torganizationData[_orgID].electionAdminAddresses == address(0),\n\t\t\t// error 36a = error incorrect null value\n\t\t\t\"error:36a\"\n\t\t);\n\n\t\trequire(\n\t\t\tUtilityLibrary.onlyAlphanumericCharacters(_orgID),\n\t\t\t// error36b = Only Alpha Numeric character allowed\n\t\t\t\"error:36b\"\n\t\t);\n\n\t\trequire(\n\t\t\tbytes(_orgName).length > 0,\n\t\t\t// error 36a = error incorrect null value\n\t\t\t\"error:36a\"\n\t\t);\n\n\t\trequire(\n\t\t\tbytes(_orgName).length < 32,\n\t\t\t// error 36c = error character length limit\n\n\t\t\t\"error:36c\"\n\t\t);\n\n\t\trequire(bytes(_adminName).length > 1);\n\n\t\trequire(\n\t\t\tbytes(_orgID).length == 3 ||\n\t\t\t\tbytes(_orgID).length == 4 ||\n\t\t\t\tbytes(_orgID).length == 5,\n\t\t\t\"Org ID should 3 - 5 characters\"\n\t\t);\n\n\t\trequire(\n\t\t\tkeccak256(abi.encodePacked(admin[msg.sender].RegisteredOrgID1)) !=\n\t\t\t\tkeccak256(abi.encodePacked(_orgID)) &&\n\t\t\t\tkeccak256(\n\t\t\t\t\tabi.encodePacked(admin[msg.sender].RegisteredOrgID2)\n\t\t\t\t) !=\n\t\t\t\tkeccak256(abi.encodePacked(_orgID)),\n\t\t\t\"Admin is registered\"\n\t\t);\n\n\t\tOrganization storage newOrg = organizationData[_orgID];\n\t\tnewOrg.orgID = _orgID;\n\t\tnewOrg.orgName = bytes32(abi.encodePacked(_orgName));\n\t\tnewOrg.orgType = _orgType;\n\t\tnewOrg.electionAdminAddresses = msg.sender;\n\t\tnewOrg.activeElectionCounter = 0;\n\t\tnewOrg.totalMembers = 1;\n\n\t\tbytes10 UniqueAdminvoterID = bytes10(\n\t\t\tabi.encodePacked(_orgID, \"-\", \"Admin\")\n\t\t);\n\n\t\tif (bytes(admin[msg.sender].RegisteredOrgID1).length == 0) {\n\t\t\tadmin[msg.sender].RegisteredOrgID1 = _orgID;\n\t\t\tadmin[msg.sender].AdminVoterIDOrg1 = UniqueAdminvoterID;\n\t\t} else if (bytes(admin[msg.sender].RegisteredOrgID2).length == 0) {\n\t\t\tadmin[msg.sender].RegisteredOrgID2 = _orgID;\n\t\t\tadmin[msg.sender].AdminVoterIDOrg2 = UniqueAdminvoterID;\n\t\t}\n\n\t\tAdminInfo.electionAdminAddress = msg.sender;\n\t\tAdminInfo.adminName = bytes32(abi.encodePacked(_adminName));\n\t\tAdminInfo.userBirthDate = _userBirthDate;\n\t\tvoterBirthDateByName[_adminName] = _userBirthDate;\n\t\tAdminInfo.isRegistered = true;\n\n\t\t++AdminInfo.adminOrgCount;\n\n\t\tregisteredAdmin[msg.sender] = true;\n\t\tvotersIDExists[UniqueAdminvoterID] = true;\n\n\t\tAdminInfo.nextOrgCreationBlock = 50 + block.number;\n\n\t\t++organizationsCounter;\n\t\t++VotreXUserCounter;\n\t}\n\n\tfunction registerVoter(\n\t\tstring memory _voterName,\n\t\tstring memory _orgID,\n\t\tbytes32 _userBirthDate,\n\t\tbytes32 uniqueVoterID\n\t) external payable onlyWhenActivated {\n\t\tVoter storage voter = voters[msg.sender];\n\t\tbytes16 VoterID16 = bytes16(abi.encodePacked(uniqueVoterID));\n\t\tbytes32 _orgID32 = bytes32(abi.encodePacked(_orgID));\n\n\t\trequire(\n\t\t\torganizationData[_orgID].totalMembers < 5000,\n\t\t\t\"Maximum member limit reached\"\n\t\t);\n\n\t\trequire(bytes(_voterName).length > 1, \"Please fill Voter Name\");\n\n\t\trequire(\n\t\t\tbytes(_voterName).length < 24,\n\t\t\t\"Voter name limit is 24 characters\"\n\t\t);\n\n\t\trequire(\n\t\t\tkeccak256(abi.encodePacked(voters[msg.sender].RegisteredOrgID1)) !=\n\t\t\t\tkeccak256(abi.encodePacked(_orgID)) &&\n\t\t\t\tkeccak256(\n\t\t\t\t\tabi.encodePacked(voters[msg.sender].RegisteredOrgID2)\n\t\t\t\t) !=\n\t\t\t\tkeccak256(abi.encodePacked(_orgID)) &&\n\t\t\t\t!registeredAdmin[msg.sender],\n\t\t\t\"Voter is registered in Org\"\n\t\t);\n\n\t\trequire(ElectionActiveCheck(_orgID) < 1, \"Election in progress!\");\n\n\t\trequire(bytes16(uniqueVoterID).length > 0);\n\n\t\trequire(\n\t\t\tbytes(organizationData[_orgID].orgID).length != 0,\n\t\t\t\"Organization does not exist\"\n\t\t);\n\n\t\tif (bytes(voter.RegisteredOrgID1).length == 0) {\n\t\t\tvoter.RegisteredOrgID1 = _orgID;\n\t\t\tvoter.VoterIDOrg1 = VoterID16;\n\t\t} else if (bytes(voter.RegisteredOrgID2).length == 0) {\n\t\t\tvoter.RegisteredOrgID2 = _orgID;\n\t\t\tvoter.VoterIDOrg2 = VoterID16;\n\t\t}\n\n\t\tvoter.VoterAddress = msg.sender;\n\t\tvoter.VoterName = _voterName;\n\t\tvoter.isRegistered = true;\n\t\tvoter.userBirthDate = _userBirthDate;\n\t\tvoterNameList[_orgID32].push(_voterName);\n\t\tvoterBirthDateByName[_voterName] = _userBirthDate;\n\t\tvotersIDExists[VoterID16] = true;\n\t\t++VotreXUserCounter;\n\t\t++organizationData[_orgID].totalMembers;\n\t}\n\n\tfunction createElection(\n\t\tstring memory _orgID,\n\t\tstring memory _userElectionID,\n\t\tstring memory _electionName,\n\t\tuint8 _candidateCount,\n\t\tbool _isHaveCandidateMode\n\t) external onlyWhenActivated onlyOrgAdmin(_orgID) {\n\t\trequire(bytes(organizationData[_orgID].orgID).length > 0);\n\n\t\trequire(\n\t\t\tbytes(_userElectionID).length > 1,\n\t\t\t// error 36a = error incorrect null value\n\t\t\t\"error 36a\"\n\t\t);\n\n\t\trequire(bytes(_userElectionID).length < 5, \"ID should < 5 characters\");\n\n\t\trequire(bytes(_electionName).length > 1);\n\n\t\trequire(bytes(_electionName).length < 25, \"Election name should < 25\");\n\n\t\trequire(\n\t\t\torganizationData[_orgID].activeElectionCounter < 10,\n\t\t\t\"Maximum events reached\"\n\t\t);\n\n\t\tbytes32 generatedElectionID = bytes32(\n\t\t\tabi.encodePacked(_orgID, \"-\", _userElectionID)\n\t\t);\n\n\t\trequire(\n\t\t\t!electionExistanceChecks[generatedElectionID],\n\t\t\t\"Election ID exists\"\n\t\t);\n\n\t\tElectionDetail storage newElection = electionInfo[generatedElectionID];\n\t\tnewElection.orgID = _orgID;\n\t\tnewElection.electionID = generatedElectionID;\n\t\tnewElection.electionName = bytes32(abi.encodePacked(_electionName));\n\t\tnewElection.status = ElectionStatus.Preparation;\n\t\telectionExistanceChecks[generatedElectionID] = true;\n\n\t\tif (_isHaveCandidateMode == true) {\n\t\t\trequire(_candidateCount > 1, \"Minimum 2 candidates!\");\n\n\t\t\tnewElection.candidateList = _candidateCount;\n\t\t} else {\n\t\t\tnewElection.candidateList = 0;\n\t\t}\n\n\t\tnewElection.isHaveCandidateMode = _isHaveCandidateMode;\n\t\telectionExistanceChecks[generatedElectionID] = true;\n\t\torganizationData[_orgID].electionIDs.push(generatedElectionID);\n\t\torganizationData[_orgID].ElectionName.push(\n\t\t\tbytes32(abi.encodePacked(_electionName))\n\t\t);\n\t\torganizationData[_orgID].electionStatus.push(\n\t\t\tElectionStatus.Preparation\n\t\t);\n\t\t++organizationData[_orgID].onPreparationElectionCounter;\n\t}\n\n\tfunction startElection(\n\t\tstring memory _userElectionID\n\t) external onlyOrgAdmin(_userElectionID) {\n\t\t// error 36a = error incorrect null value\n\t\trequire(bytes(_userElectionID).length > 0, \"error:36a\");\n\n\t\tbytes32 userElectionID = bytes32(abi.encodePacked(_userElectionID));\n\t\tstring memory orgIDs = UtilityLibrary.extractOrgId(_userElectionID);\n\n\t\tElectionDetail storage election = electionInfo[userElectionID];\n\t\trequire(bytes16(election.electionID).length > 0, \"Invalid election ID\");\n\t\trequire(\n\t\t\telection.status == ElectionStatus.Preparation,\n\t\t\t\"Election is not in preparation\"\n\t\t);\n\n\t\tif (election.isHaveCandidateMode == true) {\n\t\t\trequire(\n\t\t\t\telection.candidateList == election.candidates.length,\n\t\t\t\t\"Candidate Not full\"\n\t\t\t);\n\t\t}\n\t\telection.startTime = 5 + block.timestamp;\n\t\telection.status = ElectionStatus.Started;\n\t\t++election.waveNumber;\n\t\t++organizationData[orgIDs].activeElectionCounter;\n\t\t--organizationData[orgIDs].onPreparationElectionCounter;\n\t\tuint256 index = findElectionIndex(\n\t\t\torganizationData[orgIDs].electionIDs,\n\t\t\tuserElectionID\n\t\t);\n\t\trequire(\n\t\t\tindex < organizationData[orgIDs].electionIDs.length,\n\t\t\t\"Election not found\"\n\t\t);\n\t\torganizationData[orgIDs].electionStatus[index] = ElectionStatus.Started;\n\t}\n\n\tfunction findElectionIndex(\n\t\tbytes32[] storage array,\n\t\tbytes32 electionID\n\t) internal view returns (uint256) {\n\t\tfor (uint256 i = 0; i < array.length; i++) {\n\t\t\tif (array[i] == electionID) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\trevert(\"Election ID not found\");\n\t}\n\n\tevent CandidateStored(\n\t\tbytes32 indexed electionId,\n\t\tstring candidateName,\n\t\tuint256 voteCount\n\t);\n\n\tfunction finishElection(\n\t\tstring memory _userElectionID,\n\t\tbytes32 _dataHash,\n\t\tuint256 _threshold\n\t) external {\n\t\tstring memory orgIDs = UtilityLibrary.extractOrgId(_userElectionID);\n\t\tbytes32 packedElectionID = bytes32(abi.encodePacked(_userElectionID));\n\t\tElectionDetail storage election = electionInfo[packedElectionID];\n\t\tstring memory electionName = string(\n\t\t\tabi.encodePacked(election.electionName)\n\t\t);\n\t\tbytes32 electionIdBytes = keccak256(\n\t\t\tabi.encodePacked(_userElectionID, \"-\", electionName)\n\t\t);\n\n\t\t// Cache storage in memory to reduce storage reads\n\t\tElectionDetail storage elections = electionInfo[packedElectionID];\n\n\t\t// Validation checks\n\t\trequire(\n\t\t\telections.status == ElectionStatus.Started,\n\t\t\t\"Election is not active\"\n\t\t);\n\t\trequire(!elections.isFinished, \"Election finished\");\n\t\trequire(bytes(_userElectionID).length > 0, \"Invalid election ID\");\n\t\trequire(_dataHash.length > 0, \"Invalid data hash\");\n\n\t\tuint256 candidatesLength = elections.candidates.length;\n\t\trequire(candidatesLength >= 2, \"Not enough candidates\");\n\n\t\t// Calculate quorum threshold once\n\t\tuint256 quorumThreshold = calculateValidElection(_userElectionID);\n\n\t\t// Memory array to avoid repeated storage reads\n\t\tCandidateDetail[] memory candidatesMem = new CandidateDetail[](\n\t\t\tcandidatesLength\n\t\t);\n\t\tfor (uint256 i = 0; i < candidatesLength; i++) {\n\t\t\tcandidatesMem[i] = elections.candidates[i];\n\t\t}\n\n\t\t// Check for immediate quorum - scan once to find winning candidate\n\t\tbool quorumReached = false;\n\t\tuint256 winningCandidateIndex;\n\t\tbool kisquosientMode = false;\n\t\tuint256 passedCandidateCount = 0;\n\n\t\t// Combined loop to check all conditions at once\n\t\tfor (uint256 i = 0; i < candidatesLength; ++i) {\n\t\t\tuint256 voteCount = candidatesMem[i].candidateVoteCount;\n\n\t\t\tif (voteCount > quorumThreshold) {\n\t\t\t\tquorumReached = true;\n\t\t\t\twinningCandidateIndex = i;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tif (voteCount > _threshold) {\n\t\t\t\t\tkisquosientMode = true;\n\t\t\t\t\t++passedCandidateCount;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (quorumReached) {\n\t\t\t// Quorum reached - handle winning case\n\t\t\t_finalizeElection(\n\t\t\t\t_userElectionID,\n\t\t\t\tpackedElectionID,\n\t\t\t\torgIDs,\n\t\t\t\t_dataHash,\n\t\t\t\twinningCandidateIndex\n\t\t\t);\n\t\t\treturn;\n\t\t} else if (!quorumReached && kisquosientMode == true) {\n\t\t\t// Handle threshold-passing candidates\n\t\t\t_handleThresholdCandidates(\n\t\t\t\t_userElectionID,\n\t\t\t\telectionIdBytes,\n\t\t\t\tpassedCandidateCount,\n\t\t\t\t_threshold,\n\t\t\t\tpackedElectionID\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t\trevert(\"No candidates passed threshold\");\n\t}\n\n\t// Internal function to finalize an election\n\tfunction _finalizeElection(\n\t\tstring memory _userElectionID,\n\t\tbytes32 packedElectionID,\n\t\tstring memory orgIDs,\n\t\tbytes32 _dataHash,\n\t\tuint256 winningCandidateIndex\n\t) internal {\n\t\tElectionDetail storage elections = electionInfo[packedElectionID];\n\n\t\t// Cache winner name\n\t\tstring memory electionWinner = elections\n\t\t\t.candidates[winningCandidateIndex]\n\t\t\t.candidateName;\n\t\tstring memory adminName = getAdminName(msg.sender);\n\n\t\t// Create result record\n\t\tElectionResult storage newElectionResult = electionResults[\n\t\t\t_userElectionID\n\t\t];\n\t\tnewElectionResult.isPruned = true;\n\t\tnewElectionResult.totalVoter = elections.totalParticipants;\n\t\tnewElectionResult.adminAddress = msg.sender;\n\t\tnewElectionResult.startTime = elections.startTime;\n\t\tnewElectionResult.endTime = elections.endTime;\n\t\tnewElectionResult.digitalSignature = _dataHash;\n\t\tnewElectionResult.registeredOrganization = elections.orgID;\n\t\tnewElectionResult.electionID = packedElectionID;\n\t\tnewElectionResult.waveNumber = elections.waveNumber;\n\t\tnewElectionResult.electionName = elections.electionName;\n\t\tnewElectionResult.electionWinner = electionWinner;\n\t\tnewElectionResult.signedBy = adminName;\n\n\t\t// Mark election as finished\n\t\telections.isFinished = true;\n\t\telections.status = ElectionStatus.Finished;\n\n\t\t// Store candidates in result\n\t\tuint256 candidatesLength = elections.candidates.length;\n\t\tfor (uint256 i = 0; i < candidatesLength; ++i) {\n\t\t\tCandidateDetail storage candidate = elections.candidates[i];\n\t\t\tnewElectionResult.candidates.push(\n\t\t\t\tCandidateDetail({\n\t\t\t\t\tcandidateID: candidate.candidateID,\n\t\t\t\t\tcandidateName: candidate.candidateName,\n\t\t\t\t\tcandidateVoteCount: candidate.candidateVoteCount\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\n\t\t// Update organization data\n\t\tuint256 index = findElectionIndex(\n\t\t\torganizationData[orgIDs].electionIDs,\n\t\t\tpackedElectionID\n\t\t);\n\n\t\torganizationData[orgIDs].electionStatus[index] = ElectionStatus\n\t\t\t.Finished;\n\n\t\t// Use unchecked for simple increment/decrement\n\t\t++organizationData[orgIDs].archivedElectionCounter;\n\t\t--organizationData[orgIDs].activeElectionCounter;\n\t}\n\n\t// Internal function to handle threshold-passing candidates\n\tfunction _handleThresholdCandidates(\n\t\tstring memory _userElectionID,\n\t\tbytes32 electionIdBytes,\n\t\tuint256 passedCandidateCount,\n\t\tuint256 _threshold,\n\t\tbytes32 packedElectionID\n\t) internal {\n\t\tElectionDetail storage elections = electionInfo[packedElectionID];\n\n\t\tif (passedCandidateCount < 2) {\n\t\t\t// Single candidate passing threshold\n\t\t\t_handleSinglePassedCandidate(\n\t\t\t\telectionIdBytes,\n\t\t\t\telections,\n\t\t\t\t_threshold\n\t\t\t);\n\t\t\treturn;\n\t\t} else if (passedCandidateCount > 2) {\n\t\t\t// Multiple candidates passing threshold\n\n\t\t\tuint256[] memory lowestIndices = _findLowestVoteCandidate(\n\t\t\t\telections.candidates\n\t\t\t);\n\t\t\t_removeCandidate(elections.candidates, lowestIndices);\n\n\t\t\t_resetElectionRound(_userElectionID);\n\t\t\tdelete voterAddrList[electionIdBytes];\n\t\t\treturn;\n\t\t} else {\n\t\t\t// Exactly 2 candidates passing threshold\n\t\t\tif (elections.waveNumber <= 2) {\n\t\t\t\t// Early wave (waveNumber 1)\n\t\t\t\tfor (uint256 k = 0; k < elections.candidates.length; ++k) {\n\t\t\t\t\tif (\n\t\t\t\t\t\telections.candidates[k].candidateVoteCount > _threshold\n\t\t\t\t\t) {\n\t\t\t\t\t\ttemporalCandidates[electionIdBytes][\n\t\t\t\t\t\t\telections.candidates[k].candidateName\n\t\t\t\t\t\t].candidateName = elections.candidates[k].candidateName;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tuint256[] memory lowestIndices = _findLowestVoteCandidate(\n\t\t\t\t\telections.candidates\n\t\t\t\t);\n\t\t\t\t_removeCandidate(elections.candidates, lowestIndices);\n\n\t\t\t\t// Reset for next round\n\t\t\t\t_resetElectionRound(_userElectionID);\n\t\t\t} else {\n\t\t\t\t// Final wave (waveNumber = 2)\n\t\t\t\tuint256 winnerIndex;\n\t\t\t\tif (\n\t\t\t\t\telections.candidates[0].candidateVoteCount >\n\t\t\t\t\telections.candidates[1].candidateVoteCount\n\t\t\t\t) {\n\t\t\t\t\twinnerIndex = 0;\n\t\t\t\t} else if (\n\t\t\t\t\telections.candidates[1].candidateVoteCount >\n\t\t\t\t\telections.candidates[0].candidateVoteCount\n\t\t\t\t) {\n\t\t\t\t\twinnerIndex = 1;\n\t\t\t\t} else {\n\t\t\t\t\telections.isTiedVoting = true;\n\t\t\t\t}\n\t\t\t\t// Finalize election\n\t\t\t\t_finalizeElection(\n\t\t\t\t\t_userElectionID,\n\t\t\t\t\telectionIdBytes,\n\t\t\t\t\telections.orgID,\n\t\t\t\t\tbytes32(0),\n\t\t\t\t\twinnerIndex\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Internal function to find the candidate with lowest votes\n\tfunction _findLowestVoteCandidate(\n\t\tCandidateDetail[] storage candidates\n\t) internal view returns (uint256[] memory) {\n\t\trequire(candidates.length > 0, \"No candidates to evaluate\");\n\n\t\t// First find the lowest vote count\n\t\tuint256 lowestVotes = type(uint256).max;\n\t\tfor (uint256 i = 0; i < candidates.length; ++i) {\n\t\t\tif (candidates[i].candidateVoteCount < lowestVotes) {\n\t\t\t\tlowestVotes = candidates[i].candidateVoteCount;\n\t\t\t}\n\t\t}\n\n\t\t// Count how many candidates have the lowest vote\n\t\tuint256 lowestCount = 0;\n\t\tfor (uint256 i = 0; i < candidates.length; ++i) {\n\t\t\tif (candidates[i].candidateVoteCount == lowestVotes) {\n\t\t\t\tlowestCount++;\n\t\t\t}\n\t\t}\n\n\t\t// Create array to store indices of candidates with lowest votes\n\t\tuint256[] memory lowestIndices = new uint256[](lowestCount);\n\t\tuint256 arrayIndex = 0;\n\n\t\t// Fill array with indices\n\t\tfor (uint256 i = 0; i < candidates.length; ++i) {\n\t\t\tif (candidates[i].candidateVoteCount == lowestVotes) {\n\t\t\t\tlowestIndices[arrayIndex] = i;\n\t\t\t\tarrayIndex++;\n\t\t\t}\n\t\t}\n\n\t\treturn lowestIndices;\n\t}\n\n\t// Internal function to find the candidate with highest votes that passes a threshold\n\tfunction _findHighestVoteCandidateAboveThreshold(\n\t\tCandidateDetail[] storage candidates,\n\t\tuint256 threshold\n\t) internal view returns (uint256) {\n\t\tuint256 highestVotes = 0;\n\t\tuint256 highestIndex = type(uint256).max; // Invalid index to detect no matches\n\t\tuint256 candidatesLength = candidates.length;\n\n\t\tfor (uint256 k = 0; k < candidatesLength; ++k) {\n\t\t\tuint256 currentVotes = candidates[k].candidateVoteCount;\n\t\t\tif (currentVotes > threshold && currentVotes > highestVotes) {\n\t\t\t\thighestVotes = currentVotes;\n\t\t\t\thighestIndex = k;\n\t\t\t}\n\t\t}\n\n\t\trequire(\n\t\t\thighestIndex != type(uint256).max,\n\t\t\t\"No candidate above threshold\"\n\t\t);\n\t\treturn highestIndex;\n\t}\n\n\tfunction _handleSinglePassedCandidate(\n\t\tbytes32 electionIdBytes,\n\t\tElectionDetail storage elections,\n\t\tuint256 _threshold\n\t) internal {\n\t\t// Find the candidate that passed the threshold (should be the highest vote candidate)\n\t\tuint256 highestIndex = _findHighestVoteCandidateAboveThreshold(\n\t\t\telections.candidates,\n\t\t\t_threshold\n\t\t);\n\t\tCandidateDetail storage thresholdCandidate = elections.candidates[\n\t\t\thighestIndex\n\t\t];\n\n\t\t// Save candidate to temporal storage\n\t\ttemporalCandidates[electionIdBytes][\n\t\t\tthresholdCandidate.candidateName\n\t\t] = CandidateDetail({\n\t\t\tcandidateID: thresholdCandidate.candidateID,\n\t\t\tcandidateName: thresholdCandidate.candidateName,\n\t\t\tcandidateVoteCount: thresholdCandidate.candidateVoteCount\n\t\t});\n\n\t\t// Find and remove lowest candidate\n\t\tuint256[] memory lowestIndices = _findLowestVoteCandidate(\n\t\t\telections.candidates\n\t\t);\n\t\t_removeCandidate(elections.candidates, lowestIndices);\n\n\t\t// Reset votes for next round\n\t\tfor (uint256 m = 0; m < elections.candidates.length; ++m) {\n\t\t\telections.candidates[m].candidateVoteCount = 0;\n\t\t}\n\n\t\t// Reset voter states\n\t\taddress[] storage voterStorage = voterAddrList[electionIdBytes];\n\t\tfor (uint256 n = 0; n < voterStorage.length; ++n) {\n\t\t\thasVoted[electionIdBytes][voterStorage[n]] = false;\n\t\t}\n\t\tdelete voterAddrList[electionIdBytes];\n\n\t\telections.totalParticipants = 0;\n\t\t++elections.waveNumber;\n\t\telections.isFinished = false;\n\t\temit CandidateStored(\n\t\t\telectionIdBytes,\n\t\t\tthresholdCandidate.candidateName,\n\t\t\tthresholdCandidate.candidateVoteCount\n\t\t);\n\t}\n\n\t// Internal function to reset for next election round\n\tfunction _resetElectionRound(string memory _userElectionID) internal {\n\t\tbytes32 packedElectionID = bytes32(abi.encodePacked(_userElectionID));\n\t\tElectionDetail storage elections = electionInfo[packedElectionID];\n\t\tstring memory electionName = string(\n\t\t\tabi.encodePacked(elections.electionName)\n\t\t);\n\t\tbytes32 electionIdBytes = keccak256(\n\t\t\tabi.encodePacked(_userElectionID, \"-\", electionName)\n\t\t);\n\n\t\t// Reset votes for all candidates\n\t\tuint256 candidatesLength = elections.candidates.length;\n\t\tfor (uint256 i = 0; i < candidatesLength; ++i) {\n\t\t\telections.candidates[i].candidateVoteCount = 0;\n\t\t}\n\n\t\t// Reset voter states\n\t\taddress[] storage voterStorage = voterAddrList[electionIdBytes];\n\t\tuint256 votersLength = voterStorage.length;\n\t\tfor (uint256 j = 0; j < votersLength; ++j) {\n\t\t\thasVoted[electionIdBytes][voterStorage[j]] = false;\n\t\t}\n\t\tdelete voterAddrList[electionIdBytes];\n\n\t\t// Update election\n\t\telections.totalParticipants = 0;\n\t\t++elections.waveNumber;\n\t\telections.isFinished = false;\n\t}\n\n\t// Internal function to remove a candidate at specified index\n\tfunction _removeCandidate(\n\t\tCandidateDetail[] storage candidates,\n\t\tuint256[] memory indices\n\t) internal {\n\t\trequire(indices.length > 0, \"No candidates to remove\");\n\n\t\t// Sort indices in descending order to avoid array shifting issues\n\t\tfor (uint256 i = 0; i < indices.length; i++) {\n\t\t\tfor (uint256 j = i + 1; j < indices.length; j++) {\n\t\t\t\tif (indices[i] < indices[j]) {\n\t\t\t\t\tuint256 temp = indices[i];\n\t\t\t\t\tindices[i] = indices[j];\n\t\t\t\t\tindices[j] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Remove candidates from highest index to lowest\n\t\tfor (uint256 i = 0; i < indices.length; i++) {\n\t\t\tuint256 indexToRemove = indices[i];\n\t\t\tuint256 lastIndex = candidates.length - 1;\n\n\t\t\tif (indexToRemove != lastIndex) {\n\t\t\t\tcandidates[indexToRemove] = candidates[lastIndex];\n\t\t\t}\n\t\t\tcandidates.pop();\n\t\t}\n\t}\n\n\tfunction calculateValidElection(\n\t\tstring memory _userElectionID\n\t) private view returns (uint256) {\n\t\tbytes32 packedElectionID = bytes32(abi.encodePacked(_userElectionID));\n\t\tElectionDetail storage elections = electionInfo[packedElectionID];\n\t\tuint256 MIN_VOTES_PERCENTAGE = 1 + (elections.totalParticipants / 2);\n\n\t\treturn MIN_VOTES_PERCENTAGE;\n\t}\n\n\tfunction getOwnerAddress() external view returns (address) {\n\t\treturn VotreXOwnerAddress;\n\t}\n\n\tfunction getOwnerName() external view returns (bytes32) {\n\t\treturn VotreXOwnerName;\n\t}\n\n\tfunction getTotalUser() external view returns (uint256) {\n\t\treturn VotreXUserCounter;\n\t}\n\n\tfunction getElectionListInOrg(\n\t\tstring memory orgID\n\t)\n\t\texternal\n\t\tview\n\t\treturns (bytes32[] memory, bytes32[] memory, ElectionStatus[] memory)\n\t{\n\t\tOrganization storage org = organizationData[orgID];\n\t\treturn (org.electionIDs, org.ElectionName, org.electionStatus);\n\t}\n\n\tfunction getAdminName(\n\t\taddress adminAddress\n\t) private view returns (string memory) {\n\t\treturn string(abi.encodePacked(admin[adminAddress].adminName));\n\t}\n\n\tfunction addCandidateDetail(\n\t\tstring memory _userElectionID,\n\t\tstring memory _candidateName\n\t) external onlyOrgAdmin(_userElectionID) {\n\t\tbytes32 userElectionID = bytes32(abi.encodePacked(_userElectionID));\n\t\tElectionDetail storage election = electionInfo[userElectionID];\n\t\tstring memory orgID = UtilityLibrary.extractOrgId(_userElectionID);\n\t\tbytes32 orgIDBytes = bytes32(abi.encodePacked(orgID));\n\n\t\trequire(bytes(_userElectionID).length > 0);\n\n\t\trequire(\n\t\t\tbytes32(electionInfo[userElectionID].electionID).length > 0,\n\t\t\t// error 36a = error incorrect null value\n\t\t\t\"error:36a\"\n\t\t);\n\n\t\trequire(\n\t\t\telection.candidates.length < election.candidateList,\n\t\t\t\"Candidate limit reached\"\n\t\t);\n\n\t\trequire(bytes(_candidateName).length > 0);\n\n\t\trequire(\n\t\t\tbytes(_candidateName).length <= 24,\n\t\t\t\"name limits 24 characters\"\n\t\t);\n\n\t\trequire(\n\t\t\tUtilityLibrary.allowWhiteSpace(_candidateName),\n\t\t\t\"Candidate name can only contain alphabetical\"\n\t\t);\n\n\t\tbool isValidVoterName = false;\n\n\t\tfor (uint i = 0; i < voterNameList[orgIDBytes].length; i++) {\n\t\t\tif (\n\t\t\t\tkeccak256(abi.encodePacked(voterNameList[orgIDBytes][i])) ==\n\t\t\t\tkeccak256(abi.encodePacked(_candidateName))\n\t\t\t) {\n\t\t\t\tisValidVoterName = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\trequire(isValidVoterName, \"This Candidate is not registered\");\n\n\t\tbytes32 encryptedBirthDate = voterBirthDateByName[_candidateName];\n\t\tbool isOver60Years = UtilityLibrary.isOver60Years(\n\t\t\tencryptedBirthDate,\n\t\t\tint256(Time_Offset)\n\t\t);\n\n\t\trequire(\n\t\t\t!isOver60Years,\n\t\t\t\"Candidate must be under 60 years old and born\"\n\t\t);\n\n\t\tuint8 candidateID = uint8(election.candidates.length);\n\n\t\telection.candidates.push(\n\t\t\tCandidateDetail({\n\t\t\t\tcandidateID: candidateID,\n\t\t\t\tcandidateName: _candidateName,\n\t\t\t\tcandidateVoteCount: 0\n\t\t\t})\n\t\t);\n\t}\n\n\tfunction vote(\n\t\tstring memory _userElectionID,\n\t\tuint8 candidateID,\n\t\tstring memory _candidateName,\n\t\tbool isModeHaveCandidate\n\t) external onlyWhenActivated onlyAuthorizedMember(_userElectionID) {\n\t\tbytes32 userElectionID = bytes32(abi.encodePacked(_userElectionID));\n\t\tElectionDetail storage election = electionInfo[userElectionID];\n\t\tbytes32 electionName = election.electionName;\n\t\tbytes32 electionIdBytes = keccak256(\n\t\t\tabi.encodePacked(_userElectionID, \"-\", electionName)\n\t\t);\n\t\tstring memory orgID = UtilityLibrary.extractOrgId(_userElectionID);\n\t\tbytes32 orgIDBytes = bytes32(abi.encodePacked(orgID));\n\t\tstring memory formattedName = UtilityLibrary.capitalizeFirstLetter(\n\t\t\t_candidateName\n\t\t);\n\n\t\tbool isValidVoterName = false;\n\n\t\tif (\n\t\t\tisModeHaveCandidate == true ||\n\t\t\telection.status == ElectionStatus.HeadToHeadWave\n\t\t) {\n\t\t\trequire(\n\t\t\t\tbytes(_userElectionID).length > 0,\n\t\t\t\t\"Election ID can't be empty\"\n\t\t\t);\n\t\t\trequire(\n\t\t\t\tcandidateID < election.candidates.length,\n\t\t\t\t\"Invalid candidate ID\"\n\t\t\t);\n\t\t\trequire(\n\t\t\t\telection.status == ElectionStatus.Started,\n\t\t\t\t\"Election is not in progress\"\n\t\t\t);\n\t\t\trequire(\n\t\t\t\t!hasVoted[electionIdBytes][msg.sender],\n\t\t\t\t\"Anda sudah memilih!\"\n\t\t\t);\n\n\t\t\t++election.candidates[candidateID].candidateVoteCount;\n\t\t\t++election.totalParticipants;\n\n\t\t\thasVoted[electionIdBytes][msg.sender] = true;\n\t\t\tvoterAddrList[electionIdBytes].push(msg.sender);\n\t\t} else {\n\t\t\trequire(bytes(_candidateName).length > 0, \"Silahkan masukkan nama\");\n\t\t\trequire(\n\t\t\t\t!hasVoted[electionIdBytes][msg.sender],\n\t\t\t\t\"Anda sudah memilih!\"\n\t\t\t);\n\t\t\trequire(\n\t\t\t\telection.status == ElectionStatus.Started,\n\t\t\t\t\"Election is not in progress\"\n\t\t\t);\n\t\t\trequire(\n\t\t\t\tUtilityLibrary.allowWhiteSpace(_candidateName),\n\t\t\t\t\"Please enter alphabetical Candidate name\"\n\t\t\t);\n\n\t\t\tuint8 candidateIDs = uint8(election.candidates.length);\n\t\t\tbool candidateExists = false;\n\n\t\t\tfor (uint i = 0; i < voterNameList[orgIDBytes].length; i++) {\n\t\t\t\tif (\n\t\t\t\t\tkeccak256(abi.encodePacked(voterNameList[orgIDBytes][i])) ==\n\t\t\t\t\tkeccak256(abi.encodePacked(_candidateName))\n\t\t\t\t) {\n\t\t\t\t\tisValidVoterName = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trequire(isValidVoterName, \"This Candidate is not registered\");\n\n\t\t\tbytes32 encryptedBirthDate = voterBirthDateByName[_candidateName];\n\n\t\t\tbool isOver60Years = UtilityLibrary.isOver60Years(\n\t\t\t\tencryptedBirthDate,\n\t\t\t\tint256(Time_Offset)\n\t\t\t);\n\n\t\t\trequire(\n\t\t\t\t!isOver60Years,\n\t\t\t\t\"Candidate must be under 60 years old and born\"\n\t\t\t);\n\n\t\t\t// Loop melalui array kandidat untuk mencari nama yang cocok\n\t\t\tfor (uint256 i = 0; i < election.candidates.length; i++) {\n\t\t\t\tif (\n\t\t\t\t\tkeccak256(\n\t\t\t\t\t\tabi.encodePacked(election.candidates[i].candidateName)\n\t\t\t\t\t) == keccak256(abi.encodePacked(formattedName))\n\t\t\t\t) {\n\t\t\t\t\t// Jika kandidat ditemukan, tambahkan voteCount\n\t\t\t\t\telection.candidates[i].candidateVoteCount += 1;\n\t\t\t\t\tcandidateExists = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Jika kandidat belum ada, tambahkan kandidat baru ke array\n\t\t\tif (!candidateExists) {\n\t\t\t\tCandidateDetail memory newCandidate = CandidateDetail({\n\t\t\t\t\tcandidateID: candidateIDs,\n\t\t\t\t\tcandidateName: _candidateName,\n\t\t\t\t\tcandidateVoteCount: 1\n\t\t\t\t});\n\t\t\t\telection.candidates.push(newCandidate);\n\t\t\t}\n\t\t\thasVoted[electionIdBytes][msg.sender] = true;\n\t\t\tvoterAddrList[electionIdBytes].push(msg.sender);\n\t\t\t++election.totalParticipants;\n\t\t}\n\t}\n\n\tfunction getAllCandidates(\n\t\tstring memory _userElectionID\n\t) public view returns (CandidateDetail[] memory) {\n\t\tbytes32 userElectionID = bytes32(abi.encodePacked(_userElectionID));\n\t\t// Ambil detail pemilu berdasarkan ID\n\t\tElectionDetail storage election = electionInfo[userElectionID];\n\n\t\t// Pastikan ada kandidat dalam pemilu\n\t\trequire(\n\t\t\telection.candidates.length > 0,\n\t\t\t\"No candidates found in this election!\"\n\t\t);\n\n\t\t// Kembalikan array kandidat dari pemilu\n\t\treturn election.candidates;\n\t}\n\n\tfunction isVotreXActivated() external view returns (bool) {\n\t\treturn VotreXActivated;\n\t}\n\n\tfunction getTotalOrganization() external view virtual returns (uint256) {\n\t\treturn organizationsCounter;\n\t}\n\n\tfunction getElectionInfo(\n\t\tstring memory _userElectionID\n\t)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tbytes32 electionID,\n\t\t\tstring memory electionName,\n\t\t\tuint256 waveNumber,\n\t\t\tuint256 totalCandidates,\n\t\t\tuint8[] memory candidateIDs,\n\t\t\tstring[] memory candidateNames,\n\t\t\tuint256[] memory voteCounts,\n\t\t\tuint256 totalParticipants,\n\t\t\tElectionStatus statusElection,\n\t\t\tbool isHaveCandidateMode,\n\t\t\tuint8 candidateLimit\n\t\t)\n\t{\n\t\tbytes32 userElectionID = bytes32(abi.encodePacked(_userElectionID));\n\n\t\tElectionDetail storage election = electionInfo[userElectionID];\n\t\trequire(bytes32(election.electionID).length > 0);\n\n\t\telectionID = election.electionID;\n\t\telectionName = string(abi.encodePacked(election.electionName));\n\t\twaveNumber = election.waveNumber;\n\t\ttotalCandidates = election.candidates.length;\n\t\tcandidateLimit = election.candidateList;\n\t\tcandidateIDs = new uint8[](totalCandidates); // Initialized\n\t\tcandidateNames = new string[](totalCandidates);\n\t\tvoteCounts = new uint256[](totalCandidates);\n\t\ttotalParticipants = election.totalParticipants;\n\t\tstatusElection = electionInfo[userElectionID].status;\n\t\tisHaveCandidateMode = electionInfo[userElectionID].isHaveCandidateMode;\n\n\t\tfor (uint256 i = 0; i < totalCandidates; ++i) {\n\t\t\tcandidateIDs[i] = election.candidates[i].candidateID; // Added\n\t\t\tcandidateNames[i] = election.candidates[i].candidateName;\n\t\t\tvoteCounts[i] = election.candidates[i].candidateVoteCount;\n\t\t}\n\n\t\treturn (\n\t\t\telectionID,\n\t\t\telectionName,\n\t\t\twaveNumber,\n\t\t\ttotalCandidates,\n\t\t\tcandidateIDs,\n\t\t\tcandidateNames,\n\t\t\tvoteCounts,\n\t\t\ttotalParticipants,\n\t\t\tstatusElection,\n\t\t\tisHaveCandidateMode,\n\t\t\tcandidateLimit\n\t\t);\n\t}\n\n\tfunction getCandidateResult(\n\t\tstring memory _electionID\n\t)\n\t\tpublic\n\t\tview\n\t\treturns (\n\t\t\tuint8[] memory candidateID,\n\t\t\tstring[] memory candidateName,\n\t\t\tuint256[] memory candidateVoteCount\n\t\t)\n\t{\n\t\tuint totalCandidates = electionResults[_electionID].candidates.length;\n\n\t\tuint8[] memory candidateIDs = new uint8[](totalCandidates);\n\t\tstring[] memory candidateNames = new string[](totalCandidates);\n\t\tuint256[] memory candidateVoteCounts = new uint256[](totalCandidates);\n\n\t\tfor (uint i = 0; i < totalCandidates; i++) {\n\t\t\tcandidateIDs[i] = electionResults[_electionID]\n\t\t\t\t.candidates[i]\n\t\t\t\t.candidateID;\n\t\t\tcandidateNames[i] = electionResults[_electionID]\n\t\t\t\t.candidates[i]\n\t\t\t\t.candidateName;\n\t\t\tcandidateVoteCounts[i] = electionResults[_electionID]\n\t\t\t\t.candidates[i]\n\t\t\t\t.candidateVoteCount;\n\t\t}\n\n\t\treturn (candidateIDs, candidateNames, candidateVoteCounts);\n\t}\n\n\tfunction getUserInfo()\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tbool isRegistered,\n\t\t\tbool isAdmin,\n\t\t\taddress userAddress,\n\t\t\tstring memory userName,\n\t\t\tstring[] memory registeredOrgList,\n\t\t\tstring[] memory voterIDList\n\t\t)\n\t{\n\t\tuserAddress = msg.sender;\n\n\t\tbool isAdminRole = admin[userAddress].isRegistered;\n\t\tbool isVoterRole = voters[userAddress].isRegistered;\n\n\t\t//  Initialize arrays before assigning values\n\t\tstring[] memory RegisteredOrgIDList = new string[](2);\n\t\tstring[] memory RegisteredVoterIDList = new string[](2);\n\t\tstring memory combinedName = \"\"; // Store either admin or voter name\n\n\t\t//  If user is an Admin, fill RegisteredOrgIDList & VoterIDList\n\t\tif (isAdminRole) {\n\t\t\tElectionAdmins storage adminInfo = admin[userAddress];\n\n\t\t\tRegisteredOrgIDList[0] = adminInfo.RegisteredOrgID1;\n\t\t\tRegisteredOrgIDList[1] = adminInfo.RegisteredOrgID2;\n\n\t\t\tRegisteredVoterIDList[0] = string(\n\t\t\t\tabi.encodePacked(adminInfo.AdminVoterIDOrg1)\n\t\t\t);\n\t\t\tRegisteredVoterIDList[1] = string(\n\t\t\t\tabi.encodePacked(adminInfo.AdminVoterIDOrg2)\n\t\t\t);\n\n\t\t\tcombinedName = string(abi.encodePacked(adminInfo.adminName));\n\t\t}\n\n\t\t//  If user is a Voter, ensure the data is merged properly\n\t\tif (isVoterRole) {\n\t\t\tVoter storage voter = voters[userAddress];\n\n\t\t\tif (!isAdminRole) {\n\t\t\t\t//  If user is ONLY a voter, store voter info directly\n\t\t\t\tRegisteredOrgIDList[0] = voter.RegisteredOrgID1;\n\t\t\t\tRegisteredOrgIDList[1] = voter.RegisteredOrgID2;\n\n\t\t\t\tRegisteredVoterIDList[0] = string(\n\t\t\t\t\tabi.encodePacked(voter.VoterIDOrg1)\n\t\t\t\t);\n\t\t\t\tRegisteredVoterIDList[1] = string(\n\t\t\t\t\tabi.encodePacked(voter.VoterIDOrg2)\n\t\t\t\t);\n\n\t\t\t\tcombinedName = voter.VoterName;\n\t\t\t} else {\n\t\t\t\t//  If user is BOTH Admin & Voter, merge voter data without overwriting Admin data\n\t\t\t\tif (bytes(RegisteredOrgIDList[1]).length == 0) {\n\t\t\t\t\tRegisteredOrgIDList[1] = voter.RegisteredOrgID1;\n\t\t\t\t}\n\n\t\t\t\tif (bytes(RegisteredVoterIDList[1]).length == 0) {\n\t\t\t\t\tRegisteredVoterIDList[1] = string(\n\t\t\t\t\t\tabi.encodePacked(voter.VoterIDOrg1)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (\n\t\t\tisAdminRole || isVoterRole,\n\t\t\tisAdminRole,\n\t\t\tuserAddress,\n\t\t\tcombinedName,\n\t\t\tRegisteredOrgIDList,\n\t\t\tRegisteredVoterIDList\n\t\t);\n\t}\n\n\tfunction ElectionActiveCheck(\n\t\tstring memory _orgID\n\t) private view returns (uint256) {\n\t\treturn organizationData[_orgID].activeElectionCounter;\n\t}\n\n\tfunction determineWinner(\n\t\tstring memory _userElectionID\n\t) private view returns (string memory) {\n\t\tbytes32 userElectionID = bytes32(abi.encodePacked(_userElectionID));\n\t\tElectionDetail storage election = electionInfo[userElectionID];\n\t\tstring memory winner = \"\";\n\t\tuint256 maxVotes = 0;\n\t\tfor (uint8 i = 0; i < election.candidates.length; ++i) {\n\t\t\tif (election.candidates[i].candidateVoteCount > maxVotes) {\n\t\t\t\tmaxVotes = election.candidates[i].candidateVoteCount;\n\t\t\t\twinner = election.candidates[i].candidateName;\n\t\t\t}\n\t\t}\n\n\t\treturn winner;\n\t}\n\n\tfunction isVoterChecked(\n\t\tstring memory _userElectionID\n\t) external view returns (bool) {\n\t\tbytes32 userElectionID = bytes32(abi.encodePacked(_userElectionID));\n\t\tbytes32 electionName = electionInfo[userElectionID].electionName;\n\t\tbytes32 electionIdBytes = keccak256(\n\t\t\tabi.encodePacked(_userElectionID, \"-\", electionName)\n\t\t);\n\t\treturn hasVoted[electionIdBytes][msg.sender];\n\t}\n\n\tfunction getOrgIDHash(\n\t\tstring memory _orgID\n\t) external pure returns (bytes32) {\n\t\tbytes32 orgIDHash = keccak256(abi.encodePacked(_orgID));\n\n\t\treturn (orgIDHash);\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}